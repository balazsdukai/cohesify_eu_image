---
title: "Consolidating regression variables for EU identity inference"
author: "Balázs Dukai (<balazs.dukai@gmail.com>)"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_document: default
  html_notebook: default
  pdf_document:
    number_sections: yes
    toc: yes
subtitle: COHESIFY - The Impact of Cohesion Policy on EU Identification and is part
  of Horizon 2020 programme
papersize: a4paper
---

```{r setup, echo=FALSE, include=FALSE}
library(tidyverse)
library(haven)
library(xlsx)
library(RPostgreSQL)
db <- dbConnect(RPostgreSQL::PostgreSQL(), dbname = "nuts", user="bdukai", host="localhost")
knitr::opts_chunk$set(connection = "db")
```

\pagebreak

In this notebook I am consolidating the independent variables to NUTS level 2, version 2010.

# NUTS

Spatial data of the NUTS administrative boundaries are obtained from EuroGeographics.

**Source**\
[http://ec.europa.eu/eurostat/web/gisco/geodata/reference-data/administrative-units-statistical-units](http://ec.europa.eu/eurostat/web/gisco/geodata/reference-data/administrative-units-statistical-units)

**Copyright**\
*When data downloaded from this page is used in any printed or electronic publication, in addition to any other provisions applicable to the whole Eurostat website, data source will have to be acknowledged in the legend of the map and in the introductory page of the publication with the following copyright notice:*

© EuroGeographics for the administrative boundaries

## Version 2006

Load shapefile into database. 

```{bash shp2pgsql_2006, echo=FALSE, include=FALSE}
shp2pgsql -s 4258 -g geom -I ~/Data/NUTS/NUTS_2006_03M_SH/shape/data/NUTS_RG_03M_2006 public.nuts_2006_poly | psql -h localhost -d nuts -U bdukai
```

Generate ID hieararchy based on NUTS levels.

```{sql connection=db, include=FALSE}
CREATE
    OR REPLACE VIEW nuts_2006_levels AS WITH lvl0 AS(
        SELECT
            nuts_id id0
        FROM
            nuts_2006_poly
        WHERE
            stat_levl_ = 0
    ),
    lvl1 AS(
        SELECT
            a.*,
            b.nuts_id id1
        FROM
            lvl0 a
        JOIN nuts_2006_poly b ON
            a.id0 = SUBSTRING( b.nuts_id, 1, 2 )
        WHERE
            b.stat_levl_ = 1
    ),
    lvl2 AS(
        SELECT
            a.*,
            b.nuts_id id2
        FROM
            lvl1 a
        JOIN nuts_2006_poly b ON
            a.id1 = SUBSTRING( b.nuts_id, 1, 3 )
        WHERE
            b.stat_levl_ = 2
    ) SELECT
        a.*,
        b.nuts_id id3
    FROM
        lvl2 a
    JOIN nuts_2006_poly b ON
        a.id2 = SUBSTRING( b.nuts_id, 1, 4 )
    WHERE
        b.stat_levl_ = 3
    ORDER BY
        a.id0,
        a.id1,
        a.id2,
        b.nuts_id;
```

```{r nuts_2006, include=FALSE}
nuts_2006_levels <- dbReadTable(db, "nuts_2006_levels")
```

Generate point in the regions for version translation. The provided centroids are not sufficient, because they lie outside of island-polygons.

```{sql connection=db, echo=FALSE, include=FALSE}
CREATE
    TABLE
        IF NOT EXISTS nuts_2006_pt AS SELECT
            gid,
            nuts_id,
            stat_levl_,
            st_pointonsurface(geom) geom
        FROM
            nuts_2006_poly;

ALTER TABLE
    nuts_2006_pt ADD PRIMARY KEY(gid);

CREATE
    INDEX nuts_2006_pt_geom_idx ON
    nuts_2006_pt
        USING gist(geom);
```


## Version 2010

The level-relations are derived from the region's names, because *FR91* (a colonial island) is not covered by higher level regions, thus spatial search misses it.

```{bash shp2pgsql_2010, echo=FALSE, include=FALSE}
shp2pgsql -s 4258 -g geom -I ~/Data/NUTS/NUTS_2010_03M_SH/Data/NUTS_RG_03M_2010 public.nuts_2010_poly | psql -h localhost -d nuts -U bdukai
```

Generate ID hieararchy based on NUTS levels. Spatial search doesn't work for NUTS2010, because FR91 is not covered by higher level regions, probably a data error.

```{sql connection=db, include=FALSE}
CREATE
    OR REPLACE VIEW nuts_2010_levels AS WITH lvl0 AS(
        SELECT
            nuts_id id0
        FROM
            nuts_2010_poly
        WHERE
            stat_levl_ = 0
    ),
    lvl1 AS(
        SELECT
            a.*,
            b.nuts_id id1
        FROM
            lvl0 a
        JOIN nuts_2010_poly b ON
            a.id0 = SUBSTRING( b.nuts_id, 1, 2 )
        WHERE
            b.stat_levl_ = 1
    ),
    lvl2 AS(
        SELECT
            a.*,
            b.nuts_id id2
        FROM
            lvl1 a
        JOIN nuts_2010_poly b ON
            a.id1 = SUBSTRING( b.nuts_id, 1, 3 )
        WHERE
            b.stat_levl_ = 2
    ) SELECT
        a.*,
        b.nuts_id id3
    FROM
        lvl2 a
    JOIN nuts_2010_poly b ON
        a.id2 = SUBSTRING( b.nuts_id, 1, 4 )
    WHERE
        b.stat_levl_ = 3
    ORDER BY
        a.id0,
        a.id1,
        a.id2,
        b.nuts_id;
```

```{r nuts_2010, include=FALSE}
nuts_2010_levels <- dbReadTable(db, "nuts_2010_levels")
```

Generate point in the regions for version translation. 

```{sql connection=db, include=FALSE}
CREATE
    TABLE
        IF NOT EXISTS nuts_2010_pt AS SELECT
            gid,
            nuts_id,
            stat_levl_,
            st_pointonsurface(geom) geom
        FROM
            nuts_2010_poly;

ALTER TABLE
    nuts_2010_pt ADD PRIMARY KEY(gid);

CREATE
    INDEX nuts_2010_pt_geom_idx ON
    nuts_2010_pt
        USING gist(geom);
```

The countries that are not included in the Excel sheet `/NUTS conundrum/2006-2010.xlsx` but included in the shapefile are *"CH" "IS" "TR" "LI" "NO" "ME" "MK" "HR"*.

## Translate 2006 <-> 2010

NUTS3 regions are translated from version 2006 to 2010 by using a two-step spatial search. Firstly, the 2010 regions that were *merged* from 2006 to 2010 are spatially matched to 2006 regions, secondly the 2006 regions that were *split* from 2006 to 2010 are spatially matched to 2010 regions. Name changes and boundary shifts are also detected in the process. 

```{sql connection=db, include=FALSE}
CREATE
    OR replace VIEW nuts_translate_2006_2010 AS WITH nuts_match AS(
        -- case of merge in version 2006
        SELECT
            a.nuts_id nuts2006,
            b.nuts_id nuts2010
        FROM
            nuts_2006_pt a
        JOIN nuts_2010_poly b ON
            st_within(
                a.geom,
                b.geom
            )
        WHERE
            b.stat_levl_ = 3
            AND a.stat_levl_ = 3
    UNION
        -- case of split in version 2006
        SELECT
            b.nuts_id nuts2006,
            a.nuts_id nuts2010
        FROM
            nuts_2010_pt a
        JOIN nuts_2006_poly b ON
            st_within(
                a.geom,
                b.geom
            )
        WHERE
            b.stat_levl_ = 3
            AND a.stat_levl_ = 3
    ) SELECT
        *
    FROM
        nuts_match
    ORDER BY
        nuts2006;
```


#  Territorial typology à border regions

*As described in Regional Focus No. 1/2011. The NUTS 3-based selection of border regions refers to the regions participating in the core areas of cross-border cooperation programmes in the programming period 2007-2013. Due to NUTS boundary changes, some current NUTS 3 regions are only partly eligible as programme areas. More information on how to apply the typology can be found in the guidance note.*

Value classification in the original data set:

+ 0 – No program area
+ 1 – Programme area
+ 9 – Programme area (partly)

This variable will become *regions that **participated** in the core areas of cross-border cooperation programmes in the programming period 2007-2013*. Because the values are from 2009, thus they use NUTS 2006 (not 2010), and they refer to the programming period 2007-2013.

```{r border_in, include=FALSE}
# Read data
typo_border_regions <- read.xlsx("~/Data/COHESIFY/Datasets for regression/Territorial typology/Typologies_metadata_data_final (2).xls", sheetName = "data regional typologies", colIndex = c(1,8), endRow = 1464, header = TRUE)
# remove rows with metadata
typo_border_regions <- filter(typo_border_regions, typ_border_A != 2009)
```

Join the NUTS3 2006 variable to the NUTS2-3 2010 regions using the 2006 <-> 2010 translation schema.

```{r join_2006_2010, include=FALSE}
# Load translation schema
trsl <- dbReadTable(db, "nuts_translate_2006_2010")
# Join NUTS2-3 2010, NUTS3 2006, typ_border_A
typo_border_regions <- nuts_2010_levels %>%
    select(id2, id3) %>% 
    full_join(trsl, by = c("id3" = "nuts2010")) %>% 
    full_join(typo_border_regions, by = c("nuts2006" = "id"))
```

The aggregation of NUTS3 to NUTS2 is achieved by computing the precentage of *No programme / Programme / Programme (partly)* NUTS3 regions in the corresponding NUTS2 regions.

```{r border_aggregate, include=FALSE}
border_lvl2 <- typo_border_regions %>% 
    select(id2, typ_border_A) %>% 
    group_by(id2) %>%
    count(typ_border_A)
non_programme <- border_lvl2 %>% group_by(id2) %>% 
    mutate(nr_lvl3 = sum(n)) %>% 
    filter(typ_border_A == 0) %>% 
    mutate(non_programme = round(n/nr_lvl3, 2))
programme <- border_lvl2 %>% group_by(id2) %>% 
    mutate(nr_lvl3 = sum(n)) %>% 
    filter(typ_border_A == 1) %>% 
    mutate(programme = round(n/nr_lvl3, 2))
partially_programme <- border_lvl2 %>% group_by(id2) %>% 
    mutate(nr_lvl3 = sum(n)) %>% 
    filter(typ_border_A == 9) %>% 
    mutate(partially_programme = round(n/nr_lvl3, 2))
typ_border_lvl2_2006 <- nuts_2006_levels %>% select(id2) %>% 
    full_join(.,non_programme, by = "id2") %>% 
    full_join(., programme, by = "id2") %>%
    full_join(., partially_programme, by = "id2") %>% 
    select(id2, non_programme, programme, partially_programme) %>% 
    mutate(non_programme = case_when(is.na(.$non_programme) ~ 0.0,
                                     TRUE ~ .$non_programme)) %>% 
    mutate(programme = case_when(is.na(.$programme) ~ 0.0,
                                 TRUE ~ .$programme)) %>%
    mutate(partially_programme = case_when(is.na(.$partially_programme) ~ 0.0,
                                           TRUE ~ .$partially_programme))
rm(border_lvl2, programme, non_programme, partially_programme)
```

The results look like below:

```{r, results="asis", echo=FALSE}
knitr::kable(head(typ_border_lvl2_2006), type = "html", title = "A sample of the translated \' Territorial boundaries á border regions \' variable")
```


```{r, include=FALSE}
write.csv(typ_border_lvl2_2006, file = "typ_border_lvl2_2006.csv",
          row.names = FALSE)
```


### Question

So when I aggregate level 3 –> level 2, how do I decide how much is a level 2 a border region? Compute percent of border regions within?

What about "partially" border regions? Would they count as 50%?

NUTS2 regions are not weighted by NUTS3 population, because in case of being a programme region or not it doesn't make sense.


# Trust in national government

```{r read_trust, include=FALSE}
trust_raw <- read_sav("~/Data/COHESIFY/Datasets for regression/Trust in national government/ZA6694_v1-0-0 (1).sav")
```

From [European Values Study 2008](http://zacat.gesis.org/webview/index/en/ZACAT/ZACAT.c.ZACAT/European-Values-Study-EVS-.d.5/EVS-2008-4th-wave.d.1/EVS-2008-Integrated-Dataset.s.ZA4800/Archive-and-ID-Variables.h.175/country-abbreviation/fVariable/ZA4800_V11)

*AL Albania; AM Armenia; AT Austria; AZ Azerbaijan; BA Bosnia-Herzegovina; BE Belgium; BG Bulgaria; BY Belarus; CH Switzerland; CY Cyprus; CZ Czech Republic; DE Germany; DK Denmark; EE Estonia; ES Spain; FI Finland; FR France; GB-GBN Great Britain; GE Georgia; GR Greece; HR Croatia; HU Hungary; IE Ireland; IS Iceland; IT Italy; RS-KM Kosovo; LT Lithuania; LU Luxembourg; LV Latvia; MD Moldova; ME Montenegro; MK Macedonia; MT Malta; GB-NIR Northern Ireland; CY-TCC Northern Cyprus; NL Netherlands; NO Norway; PL Poland; PT Portugal; RO Romania; RS Serbia; RU Russia; SE Sweden; SI Slovenia; SK Slovakia; TK Turkey; UA Ukraine*

*All surveyed countries and regions, i.e. including separate samples for East-/West-Germany, Great Britain/Northern Ireland, Kosovo, and the Turkish Cypriot Community (TCC), are coded in accordance with the ISO 3166-1-alpha-2 country code, if available. ISO 3166-2 is applied for the United Kingdom subdivisions. ISO standard codes are not available for the “historical” East/West subdivision of Germany (DE-E/DE-W), Kosovo (RS-KM), and for the Turkish Cypriot Community in northern Cyprus (CY-TCC), the internationally not recognized “Turkish Republic of Northern Cyprus”.*

Countries in the study:

```{r}
table(trust_raw$isocntry)
```

Countries in the NUTS 2010 data:

```{r}
table(nuts_2010_levels$id0)
```

## Attribute translation

Dataset includes *AL* and *RS*, which are non-EU countries, thus the corresponding records are removed. Country codes that differ in the ISO standard and the NUTS declaration are translated using the schema below.


| ISO 3166-1-alpha-2; ISO 3166-2; historical | NUTS 0 | NUTS 1                                           |
|--------------------------------------------|--------|--------------------------------------------------|
| DE-E                                       | DE     | DEG, DED, DEE, DE3, DE4, DE8                     |
| DE-W                                       | DE     | DE1, DE2, DE5, DE6, DE7, DE9, DEA, DEB, DEC, DEF |
| GB-NIR                                     | UK     | UKN                                              |
| GB-GBN                                     | UK     | UK…                                              |
| CY-TCC                                     | CY     | CY0                                              |


```{r nuts_iso, include=FALSE}
# Translation schema for NUTS -> ISO3166/-2 & historical
nuts_2010_levels_iso <- nuts_2010_levels %>%
    mutate(iso = case_when(.$id1 == "UKN" ~ "GB-NIR",
                           .$id0 == "UK" & .$id1 != "UKN" ~ "GB-GBN",
                           .$id1 == "DE3" ~ "DE-E",
                           .$id1 == "DE4" ~ "DE-E",
                           .$id1 == "DE8" ~ "DE-E",
                           .$id1 == "DED" ~ "DE-E",
                           .$id1 == "DEE" ~ "DE-E",
                           .$id1 == "DEG" ~ "DE-E",
                           .$id1 == "DE1" ~ "DE-W",
                           .$id1 == "DE2" ~ "DE-W",
                           .$id1 == "DE5" ~ "DE-W",
                           .$id1 == "DE6" ~ "DE-W",
                           .$id1 == "DE7" ~ "DE-W",
                           .$id1 == "DE9" ~ "DE-W",
                           .$id1 == "DEA" ~ "DE-W",
                           .$id1 == "DEB" ~ "DE-W",
                           .$id1 == "DEC" ~ "DE-W",
                           .$id1 == "DEF" ~ "DE-W",
                           .$id0 == "EL" ~ "GR",
                           TRUE ~ .$id0
                           ))
# There is only a single NUTS region for Cyprus at all levels, but two
# values in the Trust data (CY, CY-TCC)
nuts_2010_levels_iso <- nuts_2010_levels_iso %>% 
    bind_rows(data.frame(id0 = "CY",
                         id1 = "CY0",
                         id2 = "CY00",
                         id3 = "CY000",
                         iso = "CY-TCC")) %>% 
    arrange(id0) %>% 
    select(-id3) %>% 
    distinct()
```

```{r test, include=FALSE}
t <- trust_raw["isocntry"]
t <- t %>% filter(isocntry != "AL" & isocntry != "RS")

test <- inner_join(t, nuts_2010_levels_iso, by = c("isocntry" = "iso")) # test join

test2 <- trust_raw %>% 
    slice(1:20) %>%
    select(-(q1.1:q1.36)) # these variables duplicate the "isocntry"
```


### Questions

Which variables are needed from the several hundred? Which ones describe the *Trust in government*?

Data/study description?

# Quality of Government

### Questions

Do we need */QoG/publishing-the-eqi-data2013.xlsx* *sheet:EQI2013* *col: EQI 2013*?

I didn't find indication if it is really using NUTS v2006.

# Structural Funds eligibility 2007-2013, 2014-2020

### Question

Do we need */SF eligibility/Database of the cumulative allocations to selected projects and expenditure at NUTS2 2007-2013.xlsx* *sheet:DB_NUTS2* *col: Objective*\
and */SF eligibility/Regional_policies_and_Europe_2020_RYB2016.xlsx* *sheet:Map1* *col:Class*?

# Unemployment, population at risk of poverty

### Question

Do we need */Employment and poverty/At-risk-of-poverty rate by NUTS 2 regions Eurostat_Table_tgs00103FlagDesc_58269b17-0d0c-47bb-af35-714d1b24e497.xls* *col:2013* \
and */Employment and poverty/Unemployment rates by sex, age and NUTS 2 regions (_) lfst_r_lfu3rt.xls* *col:2013*?

# Educational attainment (tertiary)

### Question

Do we need */Education/Population aged 25-64 with tertiary education (EUROSTAT) edat_lfse_04.xls* *col:2013*?

# Social progress (Basic Human Needs, Wellbeing, Opportunity)

### Question

Do we need */Social Progress Index/2016_eu_spi.xlsx* *sheet:Results* *col:European Union Regional Social Progress Index*?

# Population change, net migration

### Question

Do we need */Migration/Crude rate of net migration plus statistical adjustment demo_r_gind3.xls* *col:2013*?

# Access to social services

### Question

Data is NUTS2 not NUTS3, is is correct?

Do we need */Access to services/SGI typology.xlsx* *sheet:Sheet1* *col:SGI-aggreg.*?

# Share of population employed in agriculture

Do we need */Agriculture/htec_emp_reg2.xls* *col:2013*?


