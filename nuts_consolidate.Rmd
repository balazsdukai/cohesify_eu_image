---
title: "Consolidating regression variables for EU identity inference"
author: "Balázs Dukai (<balazs.dukai@gmail.com>)"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  pdf_document:
    number_sections: yes
    toc: yes
  html_notebook: default
  html_document: default
subtitle: COHESIFY - The Impact of Cohesion Policy on EU Identification and is part
  of Horizon 2020 programme
papersize: a4paper
---

```{r setup, echo=FALSE, include=FALSE}
library(haven)
library(xlsx)
library(RPostgreSQL)
library(tidyverse)
db <- dbConnect(RPostgreSQL::PostgreSQL(), dbname = "nuts", user="bdukai", host="localhost")
knitr::opts_chunk$set(connection = "db")
```

\pagebreak

In this notebook I am consolidating the independent variables to NUTS level 2, version 2010.

# TODO

+ filter non-EU countries from all data sets
+ weight relevant variables by population from 2010

# NUTS

Spatial data of the NUTS administrative boundaries are obtained from EuroGeographics.

**Source**\
[http://ec.europa.eu/eurostat/web/gisco/geodata/reference-data/administrative-units-statistical-units](http://ec.europa.eu/eurostat/web/gisco/geodata/reference-data/administrative-units-statistical-units)

**Copyright**\
*When data downloaded from this page is used in any printed or electronic publication, in addition to any other provisions applicable to the whole Eurostat website, data source will have to be acknowledged in the legend of the map and in the introductory page of the publication with the following copyright notice:*

© EuroGeographics for the administrative boundaries

## Version 2006

Load shapefile into database. 

```{bash shp2pgsql_2006, echo=FALSE, include=FALSE, eval=FALSE}
shp2pgsql -s 4258 -g geom -I ~/Data/NUTS/NUTS_2006_03M_SH/shape/data/NUTS_RG_03M_2006 public.nuts_2006_poly | psql -h localhost -d nuts -U bdukai
```

Generate ID hieararchy based on NUTS levels.

```{sql connection=db, include=FALSE}
CREATE
    OR REPLACE VIEW nuts_2006_levels AS WITH lvl0 AS(
        SELECT
            nuts_id id0
        FROM
            nuts_2006_poly
        WHERE
            stat_levl_ = 0
    ),
    lvl1 AS(
        SELECT
            a.*,
            b.nuts_id id1
        FROM
            lvl0 a
        JOIN nuts_2006_poly b ON
            a.id0 = SUBSTRING( b.nuts_id, 1, 2 )
        WHERE
            b.stat_levl_ = 1
    ),
    lvl2 AS(
        SELECT
            a.*,
            b.nuts_id id2
        FROM
            lvl1 a
        JOIN nuts_2006_poly b ON
            a.id1 = SUBSTRING( b.nuts_id, 1, 3 )
        WHERE
            b.stat_levl_ = 2
    ) SELECT
        a.*,
        b.nuts_id id3
    FROM
        lvl2 a
    JOIN nuts_2006_poly b ON
        a.id2 = SUBSTRING( b.nuts_id, 1, 4 )
    WHERE
        b.stat_levl_ = 3
    ORDER BY
        a.id0,
        a.id1,
        a.id2,
        b.nuts_id;
```

```{r nuts_2006, include=FALSE}
nuts_2006_levels <- dbReadTable(db, "nuts_2006_levels")
```

Generate point in the regions for version translation. The provided centroids are not sufficient, because they lie outside of island-polygons.

```{sql connection=db, echo=FALSE, include=FALSE}
CREATE
    TABLE
        IF NOT EXISTS nuts_2006_pt AS SELECT
            gid,
            nuts_id,
            stat_levl_,
            st_pointonsurface(geom) geom
        FROM
            nuts_2006_poly;

ALTER TABLE
    nuts_2006_pt ADD PRIMARY KEY(gid);

CREATE
    INDEX nuts_2006_pt_geom_idx ON
    nuts_2006_pt
        USING gist(geom);
```


## Version 2010

The level-relations are derived from the region's names, because *FR91* (a colonial island) is not covered by higher level regions, thus spatial search misses it.

```{bash shp2pgsql_2010, echo=FALSE, include=FALSE, eval=FALSE}
shp2pgsql -s 4258 -g geom -I ~/Data/NUTS/NUTS_2010_03M_SH/Data/NUTS_RG_03M_2010 public.nuts_2010_poly | psql -h localhost -d nuts -U bdukai
```

Generate ID hieararchy based on NUTS levels. Spatial search doesn't work for NUTS2010, because FR91 is not covered by higher level regions, probably a data error.

```{sql connection=db, include=FALSE}
CREATE
    OR REPLACE VIEW nuts_2010_levels AS WITH lvl0 AS(
        SELECT
            nuts_id id0
        FROM
            nuts_2010_poly
        WHERE
            stat_levl_ = 0
    ),
    lvl1 AS(
        SELECT
            a.*,
            b.nuts_id id1
        FROM
            lvl0 a
        JOIN nuts_2010_poly b ON
            a.id0 = SUBSTRING( b.nuts_id, 1, 2 )
        WHERE
            b.stat_levl_ = 1
    ),
    lvl2 AS(
        SELECT
            a.*,
            b.nuts_id id2
        FROM
            lvl1 a
        JOIN nuts_2010_poly b ON
            a.id1 = SUBSTRING( b.nuts_id, 1, 3 )
        WHERE
            b.stat_levl_ = 2
    ) SELECT
        a.*,
        b.nuts_id id3
    FROM
        lvl2 a
    JOIN nuts_2010_poly b ON
        a.id2 = SUBSTRING( b.nuts_id, 1, 4 )
    WHERE
        b.stat_levl_ = 3
    ORDER BY
        a.id0,
        a.id1,
        a.id2,
        b.nuts_id;
```

```{r nuts_2010, include=FALSE}
nuts_2010_levels <- dbReadTable(db, "nuts_2010_levels")
```

Generate point in the regions for version translation. 

```{sql connection=db, include=FALSE}
CREATE
    TABLE
        IF NOT EXISTS nuts_2010_pt AS SELECT
            gid,
            nuts_id,
            stat_levl_,
            st_pointonsurface(geom) geom
        FROM
            nuts_2010_poly;

ALTER TABLE
    nuts_2010_pt ADD PRIMARY KEY(gid);

CREATE
    INDEX nuts_2010_pt_geom_idx ON
    nuts_2010_pt
        USING gist(geom);
```

The countries that are not included in the Excel sheet `/NUTS conundrum/2006-2010.xlsx` but included in the shapefile are *"CH" "IS" "TR" "LI" "NO" "ME" "MK" "HR"*.

## Version 2013

```{bash shp2pgsql_2013, echo=FALSE, include=FALSE, eval=FALSE}
shp2pgsql -s 4258 -g geom -I ~/Data/NUTS/NUTS_2013_03M_SH/data/NUTS_RG_03M_2013 public.nuts_2013_poly | psql -h localhost -d nuts -U bdukai
```

Generate ID levels for NUTS 2013.

```{sql connection=db, include=FALSE}
CREATE
    OR REPLACE VIEW nuts_2013_levels AS WITH lvl0 AS(
        SELECT
            nuts_id id0
        FROM
            nuts_2013_poly
        WHERE
            stat_levl_ = 0
    ),
    lvl1 AS(
        SELECT
            a.*,
            b.nuts_id id1
        FROM
            lvl0 a
        JOIN nuts_2013_poly b ON
            a.id0 = SUBSTRING( b.nuts_id, 1, 2 )
        WHERE
            b.stat_levl_ = 1
    ),
    lvl2 AS(
        SELECT
            a.*,
            b.nuts_id id2
        FROM
            lvl1 a
        JOIN nuts_2013_poly b ON
            a.id1 = SUBSTRING( b.nuts_id, 1, 3 )
        WHERE
            b.stat_levl_ = 2
    ) SELECT
        a.*,
        b.nuts_id id3
    FROM
        lvl2 a
    JOIN nuts_2013_poly b ON
        a.id2 = SUBSTRING( b.nuts_id, 1, 4 )
    WHERE
        b.stat_levl_ = 3
    ORDER BY
        a.id0,
        a.id1,
        a.id2,
        b.nuts_id;
```

Generate point in the regions for version translation. 

```{sql connection=db, include=FALSE}
CREATE
    TABLE
        IF NOT EXISTS nuts_2013_pt AS SELECT
            gid,
            nuts_id,
            stat_levl_,
            st_pointonsurface(geom) geom
        FROM
            nuts_2013_poly;

ALTER TABLE
    nuts_2013_pt ADD PRIMARY KEY(gid);

CREATE
    INDEX nuts_2013_pt_geom_idx ON
    nuts_2013_pt
        USING gist(geom);
```

Get the view.

```{r nuts_2013, include=FALSE}
nuts_2013_levels <- dbReadTable(db, "nuts_2013_levels")
```


## Translate 2006 <-> 2010

NUTS3 regions are translated from version 2006 to 2010 by using a two-step spatial search. Firstly, the 2010 regions that were *merged* from 2006 to 2010 are spatially matched to 2006 regions, secondly the 2006 regions that were *split* from 2006 to 2010 are spatially matched to 2010 regions. Name changes and boundary shifts are also detected in the process. 

```{sql connection=db, include=FALSE}
CREATE
    OR replace VIEW nuts_translate_2006_2010 AS WITH nuts_match AS(
        -- case of merge in version 2006
        SELECT
            a.nuts_id nuts2006,
            b.nuts_id nuts2010
        FROM
            nuts_2006_pt a
        JOIN nuts_2010_poly b ON
            st_within(
                a.geom,
                b.geom
            )
        WHERE
            b.stat_levl_ = 3
            AND a.stat_levl_ = 3
    UNION
        -- case of split in version 2006
        SELECT
            b.nuts_id nuts2006,
            a.nuts_id nuts2010
        FROM
            nuts_2010_pt a
        JOIN nuts_2006_poly b ON
            st_within(
                a.geom,
                b.geom
            )
        WHERE
            b.stat_levl_ = 3
            AND a.stat_levl_ = 3
    ) SELECT
        *
    FROM
        nuts_match
    ORDER BY
        nuts2006;
```

```{r translation_schema, include=FALSE}
tbl_2010 <- dbReadTable(db, "nuts_translate_2006_2010")

tr_2006_2010 <- nuts_2010_levels %>%
    inner_join(tbl_2010, by = c("id3" = "nuts2010")) %>% 
    full_join(nuts_2006_levels, by = c("nuts2006" = "id3"),
              suffix = c(".2010", ".2006")) %>% 
    rename(id3.2010 = id3, id3.2006 = nuts2006)

rm(tbl_2010)
```

## Translate 2010 <-> 2013

```{sql connection=db, include=FALSE}
CREATE
    OR replace VIEW nuts_translate_2010_2013 AS WITH nuts_match AS(
        -- case of merge in version 2010
        SELECT
            a.nuts_id nuts2010,
            b.nuts_id nuts2013
        FROM
            nuts_2010_pt a
        JOIN nuts_2013_poly b ON
            st_within(
                a.geom,
                b.geom
            )
        WHERE
            b.stat_levl_ = 3
            AND a.stat_levl_ = 3
    UNION
        -- case of split in version 2010
        SELECT
            b.nuts_id nuts2010,
            a.nuts_id nuts2013
        FROM
            nuts_2013_pt a
        JOIN nuts_2010_poly b ON
            st_within(
                a.geom,
                b.geom
            )
        WHERE
            b.stat_levl_ = 3
            AND a.stat_levl_ = 3
    ) SELECT
        *
    FROM
        nuts_match
    ORDER BY
        nuts2010;
```

```{r translation_schema_2013, include=FALSE}
tbl_2013 <- dbReadTable(db, "nuts_translate_2010_2013")

tr_2010_2013 <- nuts_2013_levels %>%
    inner_join(tbl_2013, by = c("id3" = "nuts2013")) %>% 
    full_join(nuts_2010_levels, by = c("nuts2010" = "id3"),
              suffix = c(".2013", ".2010")) %>% 
    rename(id3.2013 = id3, id3.2010 = nuts2010)

rm(tbl_2013)
```

## EU member states

```{r eu_members}
eu_members <- data.frame(id0 = c("AT", "BE", "BG", "HR", "CY", "CZ", "DK", "EE",
                                 "FI", "FR", "DE", "EL", "HU", "IE", "IT", "LV",
                                 "LT", "LU", "MT", "NL", "PL", "PT", "RO", "SE",
                                 "SI", "SK", "ES", "UK"),
                         stringsAsFactors = FALSE)
```


# Territorial typology à border regions

*As described in Regional Focus No. 1/2011. The NUTS 3-based selection of border regions refers to the regions participating in the core areas of cross-border cooperation programmes in the programming period 2007-2013. Due to NUTS boundary changes, some current NUTS 3 regions are only partly eligible as programme areas. More information on how to apply the typology can be found in the guidance note.*

Value classification in the original data set:

+ 0 – No program area
+ 1 – Programme area
+ 9 – Programme area (partly)

This variable will become *regions that **participated** in the core areas of cross-border cooperation programmes in the programming period 2007-2013*. Because the values are from 2009, thus they use NUTS 2006 (not 2010), and they refer to the programming period 2007-2013.

```{r border_in, include=FALSE}
# Read data
typo_border_regions <- read.xlsx("~/Data/COHESIFY/Datasets for regression/Territorial typology/Typologies_metadata_data_final (2).xls", sheetName = "data regional typologies", colIndex = c(1,8), endRow = 1464, header = TRUE)
# remove rows with metadata
typo_border_regions <- filter(typo_border_regions, typ_border_A != 2009)
```

Join the NUTS3 2006 variable to the NUTS2-3 2010 regions using the 2006 <-> 2010 translation schema.

```{r join_2006_2010, include=FALSE}
# Join NUTS2-3 2010, NUTS3 2006, typ_border_A
typo_border_regions <- nuts_2010_levels %>%
    select(id2, id3) %>% 
    full_join(tr_2006_2010, by = c("id3" = "nuts2010")) %>% 
    full_join(typo_border_regions, by = c("nuts2006" = "id"))
```

The aggregation of NUTS3 to NUTS2 is achieved by computing the precentage of *No programme / Programme / Programme (partly)* NUTS3 regions in the corresponding NUTS2 regions.

```{r border_aggregate, include=FALSE}
border_lvl2 <- typo_border_regions %>% 
    select(id2, typ_border_A) %>% 
    group_by(id2) %>%
    count(typ_border_A)
non_programme <- border_lvl2 %>% group_by(id2) %>% 
    mutate(nr_lvl3 = sum(n)) %>% 
    filter(typ_border_A == 0) %>% 
    mutate(non_programme = round(n/nr_lvl3, 2))
programme <- border_lvl2 %>% group_by(id2) %>% 
    mutate(nr_lvl3 = sum(n)) %>% 
    filter(typ_border_A == 1) %>% 
    mutate(programme = round(n/nr_lvl3, 2))
partially_programme <- border_lvl2 %>% group_by(id2) %>% 
    mutate(nr_lvl3 = sum(n)) %>% 
    filter(typ_border_A == 9) %>% 
    mutate(partially_programme = round(n/nr_lvl3, 2))
typ_border_lvl2_2006 <- nuts_2006_levels %>% select(id2) %>% 
    full_join(.,non_programme, by = "id2") %>% 
    full_join(., programme, by = "id2") %>%
    full_join(., partially_programme, by = "id2") %>% 
    select(id2, non_programme, programme, partially_programme) %>% 
    mutate(non_programme = case_when(is.na(.$non_programme) ~ 0.0,
                                     TRUE ~ .$non_programme)) %>% 
    mutate(programme = case_when(is.na(.$programme) ~ 0.0,
                                 TRUE ~ .$programme)) %>%
    mutate(partially_programme = case_when(is.na(.$partially_programme) ~ 0.0,
                                           TRUE ~ .$partially_programme))
rm(border_lvl2, programme, non_programme, partially_programme)
```

```{r border_clean, include=FALSE}
# Count records
x_total_cnt <- typ_border_lvl2_2006 %>% 
    count()
# Count valid records
x_2006_cnt <- typ_border_lvl2_2006 %>% 
    filter(non_programme == 0.0 &
               programme == 0.0 &
           partially_programme == 0.0)
# Remove the records that have 0 for each category, because they correspond to the NUTS2006 codes
typ_border_lvl2_clean <- typ_border_lvl2_2006 %>% 
    filter(!(non_programme == 0.0 &
               programme == 0.0 &
           partially_programme == 0.0))
```

```{r border_recode, include=FALSE}
typ_border_lvl2_encoded <- typ_border_lvl2_clean %>% 
    mutate(eligibility = case_when(.$non_programme == 1.0 ~ "not eligible",
                                  .$programme == 1.0 ~ "eligible",
                                  .$non_programme < 1.0 &
                                      .$programme < 1.0 ~ "partially"))
```



The results look like below:

```{r, results="asis", echo=FALSE}
knitr::kable(head(typ_border_lvl2_encoded), type = "html", title = "A sample of the translated \' Territorial boundaries á border regions \' variable")
```


```{r, include=FALSE}
write.csv(typ_border_lvl2_encoded, file = "./results/typ_border_lvl2_clean.csv",
          row.names = FALSE)
```

```{r clean_up}
rm(typ_border_lvl2_2006, typ_border_lvl2_clean, typo_border_regions, x_total_cnt, x_2006_cnt)
```

# Trust in national government

```{r read_trust, include=FALSE}
trust_raw <- read_sav("~/Data/COHESIFY/Datasets for regression/Trust in national government/ZA6694_v1-0-0 (1).sav")
```

From [European Values Study 2008](http://zacat.gesis.org/webview/index/en/ZACAT/ZACAT.c.ZACAT/European-Values-Study-EVS-.d.5/EVS-2008-4th-wave.d.1/EVS-2008-Integrated-Dataset.s.ZA4800/Archive-and-ID-Variables.h.175/country-abbreviation/fVariable/ZA4800_V11)

*AL Albania; AM Armenia; AT Austria; AZ Azerbaijan; BA Bosnia-Herzegovina; BE Belgium; BG Bulgaria; BY Belarus; CH Switzerland; CY Cyprus; CZ Czech Republic; DE Germany; DK Denmark; EE Estonia; ES Spain; FI Finland; FR France; GB-GBN Great Britain; GE Georgia; GR Greece; HR Croatia; HU Hungary; IE Ireland; IS Iceland; IT Italy; RS-KM Kosovo; LT Lithuania; LU Luxembourg; LV Latvia; MD Moldova; ME Montenegro; MK Macedonia; MT Malta; GB-NIR Northern Ireland; CY-TCC Northern Cyprus; NL Netherlands; NO Norway; PL Poland; PT Portugal; RO Romania; RS Serbia; RU Russia; SE Sweden; SI Slovenia; SK Slovakia; TK Turkey; UA Ukraine*

*All surveyed countries and regions, i.e. including separate samples for East-/West-Germany, Great Britain/Northern Ireland, Kosovo, and the Turkish Cypriot Community (TCC), are coded in accordance with the ISO 3166-1-alpha-2 country code, if available. ISO 3166-2 is applied for the United Kingdom subdivisions. ISO standard codes are not available for the “historical” East/West subdivision of Germany (DE-E/DE-W), Kosovo (RS-KM), and for the Turkish Cypriot Community in northern Cyprus (CY-TCC), the internationally not recognized “Turkish Republic of Northern Cyprus”.*

Countries in the study:

```{r}
table(trust_raw$isocntry)
```

Countries in the NUTS 2010 data:

```{r}
table(nuts_2010_levels$id0)
```

## Attribute translation

Dataset includes *AL* and *RS*, which are non-EU countries, thus the corresponding records are removed. Country codes that differ in the ISO standard and the NUTS declaration are translated using the schema below.


| ISO 3166-1-alpha-2; ISO 3166-2; historical | NUTS 0 | NUTS 1                                           |
|--------------------------------------------|--------|--------------------------------------------------|
| DE-E                                       | DE     | DEG, DED, DEE, DE3, DE4, DE8                     |
| DE-W                                       | DE     | DE1, DE2, DE5, DE6, DE7, DE9, DEA, DEB, DEC, DEF |
| GB-NIR                                     | UK     | UKN                                              |
| GB-GBN                                     | UK     | UK…                                              |
| CY-TCC                                     | CY     | CY0                                              |


```{r nuts_iso, include=FALSE}
# Translation schema for NUTS -> ISO3166/-2 & historical
nuts_2010_levels_iso <- nuts_2010_levels %>%
    mutate(iso = case_when(.$id1 == "UKN" ~ "GB-NIR",
                           .$id0 == "UK" & .$id1 != "UKN" ~ "GB-GBN",
                           .$id1 == "DE3" ~ "DE-E",
                           .$id1 == "DE4" ~ "DE-E",
                           .$id1 == "DE8" ~ "DE-E",
                           .$id1 == "DED" ~ "DE-E",
                           .$id1 == "DEE" ~ "DE-E",
                           .$id1 == "DEG" ~ "DE-E",
                           .$id1 == "DE1" ~ "DE-W",
                           .$id1 == "DE2" ~ "DE-W",
                           .$id1 == "DE5" ~ "DE-W",
                           .$id1 == "DE6" ~ "DE-W",
                           .$id1 == "DE7" ~ "DE-W",
                           .$id1 == "DE9" ~ "DE-W",
                           .$id1 == "DEA" ~ "DE-W",
                           .$id1 == "DEB" ~ "DE-W",
                           .$id1 == "DEC" ~ "DE-W",
                           .$id1 == "DEF" ~ "DE-W",
                           .$id0 == "EL" ~ "GR",
                           TRUE ~ .$id0
                           ))
# There is only a single NUTS region for Cyprus at all levels, but two
# values in the Trust data (CY, CY-TCC)
nuts_2010_levels_iso <- nuts_2010_levels_iso %>% 
    bind_rows(data.frame(id0 = "CY",
                         id1 = "CY0",
                         id2 = "CY00",
                         id3 = "CY000",
                         iso = "CY-TCC")) %>% 
    arrange(id0) %>% 
    select(-id3) %>% 
    distinct()
```


```{r trust_translate, include=FALSE}
trust_translate <- trust_raw %>% 
    select(isocntry, qa8a_7) %>% 
    inner_join(nuts_2010_levels_iso, by = c("isocntry" = "iso")) %>% 
    distinct() %>% 
    select(id2, qa8a_7) %>% 
    rename(trust_gov = qa8a_7)
```

# Quality of Government

Source: THE QOG EU REGIONAL DATASET 2016

*Charron, Nicholas, Stefan Dahlberg, Sören Holmberg, Bo Rothstein, Anna Khomenko & Richard Svensson. 2016. The Quality of Government EU Regional Dataset, version Sep16. University of Gothenburg: The Quality of Government Institute, http://www.qog.pol.gu.se*

*Charron, Nicholas, Lewis Dijkstra and Victor Lapuente. 2015. Mapping the Regional Divide in Europe: A Measure for Assessing Quality of Government in 206 European Regions. Social Indicators Research. vol 122 (2): 315-346.*

*Charron, Nicholas, Lewis Dijkstra and Victor Lapuente. 2014. Regional Governance Matters: Quality of Government within European Union Member States. Regional Studies, 48(1): 68-90.*

*Charron, Nicholas, Victor Lapuente and Bo Rothstein. 2013. Quality of Government and Corruption from a European Perspective: A Comparative Study of Good Government in EU Regions. Edward Elgar Publishing.*

Date of access: 2016-04-25\
Nomenclature: NUTS 2006 level 2

Variable description (*eqi_eqi*):

*The European Quality of Government Index - the overall EQI regional estimates. The final regional index was the result of aggregating the scores for the three pillars for each region. To calculate the final score for each country and region, the regional scores for each of the countries included in the 2013 survey were aggregated by regional population weights. This national average of regional scores is used to elucidate the extent to which regionx in country conforms to the national QoG standard, which is done by subtracting the national average from each region's score. A positive score for a region implies that it is above the national mean; conversely, a negative score indicates that the regions QoG performance is below the national mean. In the final index, this regional score is added to the national WGI score, so that each region's score is adjusted; centered around the WGI. In combining the regional and WGI data, none of the regional variation within countries is lost.*


```{r read_qog, include=FALSE}
qog_raw <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/QoG/publishing-the-eqi-data2013.xlsx",
    sheetName = "EQI2013", colIndex = c(1,9), startRow = 4, endRow = 251, 
    header = TRUE, stringsAsFactors = FALSE) %>% 
    rename(nuts_2006 = NUTS, eqi_2013 = EQI.2013)
```

```{r qog_nuts2, include=FALSE}
# Get NUTS2 regions of input
qog_raw_nuts2 <- qog_raw %>% 
    select(nuts_2006) %>% 
    filter(nchar(nuts_2006) == 4)
```

Translate NUTS 2006 to 2010.

```{r qog_translate, include=FALSE}
qog_translate <- qog_raw %>% 
    filter(nchar(nuts_2006) >= 4) %>% 
    inner_join(tr_2006_2010, by = c("nuts_2006" = "id2.2006")) %>%
    rename(id2.2006 = nuts_2006) %>% 
    select(id2.2010, eqi_2013) %>% 
    distinct()
```

The comparison of the translated to the original reveals that the *EQI 2013* variables in fact use a mix of NTUS 2006/2010 regions, because *HR* is already mapped as NUTS 2010, while the rest of the countries as 2006.

```{r check_qog}
no_match <- full_join(qog_translate, qog_raw_nuts2,
                      by = c("id2.2006" = "nuts_2006")) %>% 
    filter(is.na(eqi_2013)) %>% 
    arrange(id2.2006)
```

The error is corrected by manually assigning the value to *HR04*.

```{r correct_qog, include=FALSE}
qog_translate[qog_translate$id2.2010 == "HR04", "eqi_2013"] <- qog_raw[qog_raw$nuts_2006 == "HR04", "eqi_2013"]
```


```{r clean_up_qog}
rm(no_match, qog_translate, qog_raw, qog_raw_nuts2)
```

# Structural Funds eligibility 2007-2013, 2014-2020

```{r read_struct, include=FALSE}
struct_raw_2007 <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/SF eligibility/Database of the cumulative allocations to selected projects and expenditure at NUTS2 2007-2013.xlsx",
    sheetIndex = 1, colIndex = c(4,7), startRow = 1, endRow = 17208, 
    header = TRUE, stringsAsFactors = FALSE) %>% 
    rename(nuts_2010 = Location.Cd, class = Objective)
struct_raw_2014 <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/SF eligibility/Regional_policies_and_Europe_2020_RYB2016.xlsx",
    sheetIndex = 1, colIndex = c(1,4), startRow = 1, endRow = 287, 
    header = TRUE, stringsAsFactors = FALSE,
    colClasses = c("character", "numeric")) %>% 
    rename(nuts_2010 = NUTS, class = Class)
```

```{r struct_prep, include=FALSE}
struct_2007_prep <- struct_raw_2007 %>% 
    select(nuts_2010, class) %>% 
    distinct() %>% 
    arrange(nuts_2010)
```

### Question

Do we need */SF eligibility/Database of the cumulative allocations to selected projects and expenditure at NUTS2 2007-2013.xlsx* *sheet:DB_NUTS2* *col: Objective*?\
What are the programe codes? Which are relevant?

This */SF eligibility/Regional_policies_and_Europe_2020_RYB2016.xlsx* *sheet:Map1* *col:Class*?

# Unemployment, population at risk of poverty

## Poverty rate(POV_RT)

People at risk of poverty or social exclusion, from *Europe 2020 Index based on the distances to 4 of the 8 Europe 2020 Strategy*.

Source: ESPON Database Portal\
Date of access: 2016-12-02 12:32:59\
Nomenclature: NUTS 2010 level 2

```{r pov_load, include=FALSE}
pov_raw <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/Employment and poverty/At-risk-of-poverty rate by NUTS 2 regions Eurostat_Table_tgs00103FlagDesc_58269b17-0d0c-47bb-af35-714d1b24e497.xls",
    sheetIndex = 1, colIndex = c(1,14), startRow = 3, endRow = 184, 
    header = TRUE, stringsAsFactors = FALSE, colClasses = c("character", "numeric"))
names(pov_raw) <- c("nuts_2010", "poverty_2013")
```

The coverage is heterogenous, some countries have NUTS2 level poverty values, while others are aggregae to NUTS0 level. The poverty values on NUTS0 level are the weighted average of the poverty values of the lower level NUTS regions, if these values exists.

```{r pov_prep, include=FALSE}
pov_lvl0 <- pov_raw %>% filter(nchar(nuts_2010) == 2) %>% 
    rename(id0 = nuts_2010)
pov_lvl1 <- pov_raw %>% filter(nchar(nuts_2010) == 3) %>% 
    mutate(id0 = substr(nuts_2010, 0, 2)) %>% 
    rename(id1 = nuts_2010)
pov_lvl2 <- pov_raw %>% filter(nchar(nuts_2010) == 4) %>% 
    mutate(id0 = substr(nuts_2010, 0, 2)) %>% 
    rename(id2 = nuts_2010) %>% 
    inner_join(eu_members, by = "id0")

pov_all <- pov_lvl0 %>% 
    full_join(pov_lvl1, by = "id0", suffix = c(".id0", ".id1")) %>% 
    full_join(pov_lvl2, by = "id0") %>% 
    rename(poverty_2013.id2 = poverty_2013) %>% 
    inner_join(eu_members, by = "id0") %>%
    arrange(id0)

# The list of countries that have only NUTS0 level poverty values
pov_cntry <- pov_all %>% 
    filter(is.na(poverty_2013.id2) & is.na(poverty_2013.id1)) %>%
    select(id0, poverty_2013.id0) %>% 
    distinct()
```

Countries that have only NUTS0 level poverty values:

```{r,echo=FALSE}
pov_cntry$id0
```

Combine everything and input country average for the missing values in Finland.

```{r pov_combine, include=FALSE}
pov_nuts2 <- pov_cntry %>% 
    inner_join(nuts_2010_levels, by = "id0") %>% 
    select(id2, poverty_2013.id0) %>% 
    rename(poverty_2013 = poverty_2013.id0) %>% 
    distinct() %>% 
    bind_rows(select(pov_lvl2, id2, poverty_2013)) %>% 
    arrange(id2)

# input country average for the missing values in Finland
pov_nuts2[substr(pov_nuts2$id2, 0, 2) == "FI" & is.na(pov_nuts2$poverty_2013),
          "poverty_2013"] <- pov_lvl0[pov_lvl0$id0 == "FI", "poverty_2013"]
```


### Question

Finland has missing values in some NUTS2 region, country average was inputed.

## Unemployment

Unemployment rate of persons aged 15-74.

```{r unemp_load, include=FALSE}
unemp_raw <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/Employment and poverty/Unemployment rates by sex, age and NUTS 2 regions (_) lfst_r_lfu3rt.xls",
    sheetIndex = 1, colIndex = c(1,4), startRow = 11, endRow = 502, 
    header = TRUE, stringsAsFactors = FALSE, colClasses = c("character", "numeric"))
names(unemp_raw) <- c("nuts_2013", "unemployment_2013")
```

Translate NUTS 2013 to 2010.

```{r unemp_translate, include=FALSE}
unemp_translate <- unemp_raw %>%
    filter(nchar(nuts_2013) >= 4) %>% 
    inner_join(tr_2010_2013, by = c("nuts_2013" = "id2.2013")) %>% 
    select(id2.2010, unemployment_2013) %>% 
    distinct()
```


# Educational attainment (tertiary)

Population aged 25-64 with tertiary education, NUTS 2 regions (%) [edat_lfse_04].

Source: Eurostat\
Last update: 2016-10-13\
Date of access: 2016-12-04\
Nomenclature: NUTS 2013 level 3

```{r edu_load, include=FALSE}
edu_raw <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/Education/Population aged 25-64 with tertiary education (EUROSTAT) edat_lfse_04.xls",
    sheetIndex = 1, colIndex = c(1,4), startRow = 12, endRow = 497, 
    header = TRUE, stringsAsFactors = FALSE, colClasses = c("character", "numeric"))
names(edu_raw) <- c("nuts_2013", "education_2013")
```

Translate NUTS 2013 to 2010.

```{r edu_translate, include=FALSE}
edu_translate <- edu_raw %>%
    filter(nchar(nuts_2013) >= 4) %>% 
    inner_join(tr_2010_2013, by = c("nuts_2013" = "id2.2013")) %>% 
    select(id2.2010, education_2013) %>% 
    distinct()
```

# Social progress (Basic Human Needs, Wellbeing, Opportunity)

```{r soc_load, include=FALSE}
soc_raw <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/Social Progress Index/2016_eu_spi.xlsx",
    sheetIndex = 1, colIndex = c(1,4), startRow = 1, endRow = 273, 
    header = TRUE, stringsAsFactors = FALSE,
    colClasses = c("character", "numeric")) %>% 
    rename(nuts_2010 = NUTS.Code.2010,
           soc_idx = European.Union.Regional.Social.Progress.Index)
```


# Population change, net migration

Population change - Demographic balance and crude rates at regional level (NUTS 3) [demo_r_gind3]

Source: Eurostat\
Last update: 2016-10-28\
Date of access: 2016-12-04\
Nomenclature: NUTS 2010/2013 level 3

```{r migr_load, include=FALSE}
migr_raw <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/Migration/Crude rate of net migration plus statistical adjustment demo_r_gind3.xls",
    sheetIndex = 1, colIndex = c(1,4), startRow = 9, endRow = 2119, 
    header = TRUE, stringsAsFactors = FALSE, colClasses = c("character", "numeric"))
names(migr_raw) <- c("nuts_2010", "migration_2013")
```

```{r migr_prep, include=FALSE}
migr_prep <- migr_raw %>% 
    filter(nchar(nuts_2010) == 4) %>% 
    mutate(id0 = substr(nuts_2010, 0, 2)) %>% 
    inner_join(eu_members, by = "id0") %>% 
    select(-id0)

# The 2013 regions that in the data but are not NUTS 2010 regions
n2013 <- migr_prep %>% 
    full_join(nuts_2010_levels, by = c("nuts_2010" = "id2")) %>% 
    select(-id3) %>% 
    distinct() %>% 
    filter(is.na(id0))

# The 2010 regions that are in the data but are not NUTS 2013 regions
n2010 <- migr_prep %>% 
    full_join(nuts_2013_levels, by = c("nuts_2010" = "id2")) %>% 
    select(-id3) %>% 
    distinct() %>% 
    filter(is.na(id0))

# Put it together and filter out 2013 regions
migr_clean <- migr_prep %>%
    filter(!(nuts_2010 %in% n2013$nuts_2010)) %>% 
    arrange(nuts_2010) %>% 
    rename(id2 = nuts_2010)
```

```{r migr_check, include=FALSE}
# Check if all EU members are present, should give 28
migr_clean %>%
    mutate(x = substr(id2, 0, 2)) %>% 
    select(x) %>% 
    n_distinct()
```


The data set uses a NUTS 2010 nomenclature but still the NUTS1 regions *EL5* and *EL6* are present, duplicating the values of their corresponding NUTS 2010 regions (*EL1* and *EL2*). Therefore *EL5* and *EL6* are removed.

Similarly in case of France, the NUTS 2010 regions *FR91, FR92, FR93, FR94* are present, and also their corresponding NUTS 2013 versions *FRA2, FRA3, FRA4*, while *FRA1, FRA5* is missing value. The NUTS 2013 regions present novel data compared to their 2010 version. Because the majority of the data correspond to NUTS 2010 regions, the NUTS 2013 regions of France are removed.

# Access to social services

The record for *Saarland* was missing its NUTS code thus it was manually added.

```{r acc2soc_load, include=FALSE}
acc2soc_raw <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/Access to services/SGI typology.xlsx",
    sheetIndex = 1, colIndex = c(1,7), startRow = 1, endRow = 287, 
    header = TRUE, stringsAsFactors = FALSE) %>% 
    rename(nuts_2006 = NUTS2, sgi_aggregated = SGI.aggreg.)
```

Translate NUTS 2006 to 2010.

```{r acc2soc_tranlate, include=FALSE}
acc2soc_translate <- acc2soc_raw %>% 
    inner_join(tr_2006_2010, by = c("nuts_2006" = "id2.2006")) %>% 
    rename(id2.2006 = nuts_2006) %>% 
    select(id2.2010, sgi_aggregated) %>% 
    distinct() %>% 
    mutate(x = substr(id2.2010, 0, 2)) %>% 
    inner_join(eu_members, by = c("x" = "id0"))
```

Compare the translated and the original to check if everything is correct. Croatia (*HR*) is not present in the data.

```{r check_acc2soc, include=FALSE}
# Check if all EU members are present, should give 28
acc2soc_translate %>%
    mutate(x = substr(id2.2010, 0, 2)) %>% 
    select(x) %>% 
    distinct()
```


# Share of population employed in agriculture

Agriculture, forestry and fishing; mining and quarrying\
Percentage of total employment


```{r agr_load, include=FALSE}
agr_raw <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/Agriculture/htec_emp_reg2.xls",
    sheetIndex = 1, colIndex = c(1,7), startRow = 1442, endRow = 1910, 
    header = TRUE, stringsAsFactors = FALSE,
    colClasses = c("character", "numeric")) %>% 
    rename(x = GEO.TIME,
           agr_share = X2013)
```

```{r agr_prep, include=FALSE}
agr_clean <- agr_raw
agr_clean$nuts_2010 <- unlist(lapply(strsplit(agr_raw$x, " "), function(x) x[1]))
agr_clean <- agr_clean %>% select(-x)

agr_lvl0 <- agr_clean %>% filter(nchar(nuts_2010) == 2) %>% 
    rename(id0 = nuts_2010)
agr_lvl1 <- agr_clean %>% filter(nchar(nuts_2010) == 3) %>% 
    mutate(id0 = substr(nuts_2010, 0, 2)) %>% 
    rename(id1 = nuts_2010)
agr_lvl2 <- agr_clean %>% filter(nchar(nuts_2010) == 4) %>% 
    mutate(id0 = substr(nuts_2010, 0, 2)) %>% 
    mutate(id1 = substr(nuts_2010, 0, 3)) %>% 
    rename(id2 = nuts_2010)

agr_all <- agr_lvl0 %>% 
    full_join(agr_lvl1, by = "id0", suffix = c(".id0", ".id1")) %>% 
    full_join(agr_lvl2, by = "id1") %>% 
    rename(agr_share.id2 = agr_share, id0 = id0.x) %>% 
    select(-id0.y) %>%
    inner_join(eu_members, by = "id0") %>% 
    arrange(id0)

# Input country average to missing NUTS2 values
missing <- agr_all %>% filter(is.na(agr_share.id2))

for (r in missing$id2) {
    # if NUTS1 value missing
    if (is.na(agr_all[agr_all$id2 == r, "agr_share.id1"])) {
        agr_all[agr_all$id2 == r,
                "agr_share.id2"] <- agr_all[agr_all$id2 == r, "agr_share.id0"]
    } else {
    # NUTS1 value present
        agr_all[agr_all$id2 == r,
                "agr_share.id2"] <- agr_all[agr_all$id2 == r, "agr_share.id1"]
    }
}

agr_clean <- agr_all %>%
    select(id2, agr_share.id2) %>% 
    rename(agr_share = agr_share.id2)
```

The NUTS2 regions below are missing values. For these regions the corresponding NUTS1 value is inputed if available, otherwise the corresponding NUTS0 value.

```{r agr_missing_table, results='asis', echo=FALSE}
knitr::kable(missing, caption = "NUTS2 regions with missing agriculture index values")
```


### Question

Is the correct section read in?
