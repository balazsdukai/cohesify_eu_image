---
title: "Consolidating regression variables for EU identity inference"
author: "Balázs Dukai (<balazs.dukai@gmail.com>)"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  pdf_document:
    number_sections: yes
    toc: yes
  html_notebook:
    number_sections: yes
    toc: yes
  html_document: default
subtitle: COHESIFY - The Impact of Cohesion Policy on EU Identification and is part
  of Horizon 2020 programme
papersize: a4paper
---

```{r setup, echo=FALSE, include=TRUE, message=FALSE}
library(haven)
library(xlsx)
library(RPostgreSQL)
library(tidyverse)
library(hrbrthemes)
db <- dbConnect(RPostgreSQL::PostgreSQL(), dbname = "nuts", user="bdukai", host="localhost")
knitr::opts_chunk$set(connection = "db")
```

\pagebreak

In this notebook I am consolidating the independent variables to NUTS level 2, version 2010.

# NUTS

Spatial data of the NUTS administrative boundaries are obtained from EuroGeographics.

**Source**\
[http://ec.europa.eu/eurostat/web/gisco/geodata/reference-data/administrative-units-statistical-units](http://ec.europa.eu/eurostat/web/gisco/geodata/reference-data/administrative-units-statistical-units)

**Copyright**\
*When data downloaded from this page is used in any printed or electronic publication, in addition to any other provisions applicable to the whole Eurostat website, data source will have to be acknowledged in the legend of the map and in the introductory page of the publication with the following copyright notice:*

© EuroGeographics for the administrative boundaries

## Version 2006

Load shapefile into database. 

```{bash shp2pgsql_2006, echo=FALSE, include=TRUE, eval=FALSE}
shp2pgsql -s 4258 -g geom -I ~/Data/NUTS/NUTS_2006_03M_SH/shape/data/NUTS_RG_03M_2006 public.nuts_2006_poly | psql -h localhost -d nuts -U bdukai
```

Generate ID hieararchy based on NUTS levels.

```{sql connection=db, include=TRUE}
CREATE
    OR REPLACE VIEW nuts_2006_levels AS WITH lvl0 AS(
        SELECT
            nuts_id id0
        FROM
            nuts_2006_poly
        WHERE
            stat_levl_ = 0
    ),
    lvl1 AS(
        SELECT
            a.*,
            b.nuts_id id1
        FROM
            lvl0 a
        JOIN nuts_2006_poly b ON
            a.id0 = SUBSTRING( b.nuts_id, 1, 2 )
        WHERE
            b.stat_levl_ = 1
    ),
    lvl2 AS(
        SELECT
            a.*,
            b.nuts_id id2
        FROM
            lvl1 a
        JOIN nuts_2006_poly b ON
            a.id1 = SUBSTRING( b.nuts_id, 1, 3 )
        WHERE
            b.stat_levl_ = 2
    ) SELECT
        a.*,
        b.nuts_id id3
    FROM
        lvl2 a
    JOIN nuts_2006_poly b ON
        a.id2 = SUBSTRING( b.nuts_id, 1, 4 )
    WHERE
        b.stat_levl_ = 3
    ORDER BY
        a.id0,
        a.id1,
        a.id2,
        b.nuts_id;
```

```{r nuts_2006, include=TRUE}
nuts_2006_levels <- dbReadTable(db, "nuts_2006_levels")
```

Generate point in the regions for version translation. The provided centroids are not sufficient, because they lie outside of island-polygons.

```{sql connection=db, echo=FALSE, include=TRUE}
CREATE
    TABLE
        IF NOT EXISTS nuts_2006_pt AS SELECT
            gid,
            nuts_id,
            stat_levl_,
            st_pointonsurface(geom) geom
        FROM
            nuts_2006_poly;

ALTER TABLE
    nuts_2006_pt ADD PRIMARY KEY(gid);

CREATE
    INDEX nuts_2006_pt_geom_idx ON
    nuts_2006_pt
        USING gist(geom);
```


## Version 2010

The level-relations are derived from the region's names, because *FR91* (a colonial island) is not covered by higher level regions, thus spatial search misses it.

```{bash shp2pgsql_2010, echo=FALSE, include=TRUE, eval=FALSE}
shp2pgsql -s 4258 -g geom -I ~/Data/NUTS/NUTS_2010_03M_SH/Data/NUTS_RG_03M_2010 public.nuts_2010_poly | psql -h localhost -d nuts -U bdukai
```

Generate ID hieararchy based on NUTS levels. Spatial search doesn't work for NUTS2010, because FR91 is not covered by higher level regions, probably a data error.

```{sql connection=db, include=TRUE}
CREATE
    OR REPLACE VIEW nuts_2010_levels AS WITH lvl0 AS(
        SELECT
            nuts_id id0
        FROM
            nuts_2010_poly
        WHERE
            stat_levl_ = 0
    ),
    lvl1 AS(
        SELECT
            a.*,
            b.nuts_id id1
        FROM
            lvl0 a
        JOIN nuts_2010_poly b ON
            a.id0 = SUBSTRING( b.nuts_id, 1, 2 )
        WHERE
            b.stat_levl_ = 1
    ),
    lvl2 AS(
        SELECT
            a.*,
            b.nuts_id id2
        FROM
            lvl1 a
        JOIN nuts_2010_poly b ON
            a.id1 = SUBSTRING( b.nuts_id, 1, 3 )
        WHERE
            b.stat_levl_ = 2
    ) SELECT
        a.*,
        b.nuts_id id3
    FROM
        lvl2 a
    JOIN nuts_2010_poly b ON
        a.id2 = SUBSTRING( b.nuts_id, 1, 4 )
    WHERE
        b.stat_levl_ = 3
    ORDER BY
        a.id0,
        a.id1,
        a.id2,
        b.nuts_id;
```

```{r nuts_2010, include=TRUE}
nuts_2010_levels <- dbReadTable(db, "nuts_2010_levels")
```

Generate point in the regions for version translation. 

```{sql connection=db, include=TRUE}
CREATE
    TABLE
        IF NOT EXISTS nuts_2010_pt AS SELECT
            gid,
            nuts_id,
            stat_levl_,
            st_pointonsurface(geom) geom
        FROM
            nuts_2010_poly;

ALTER TABLE
    nuts_2010_pt ADD PRIMARY KEY(gid);

CREATE
    INDEX nuts_2010_pt_geom_idx ON
    nuts_2010_pt
        USING gist(geom);
```

The countries that are not included in the Excel sheet `/NUTS conundrum/2006-2010.xlsx` but included in the shapefile are *"CH" "IS" "TR" "LI" "NO" "ME" "MK" "HR"*.

## Version 2013

```{bash shp2pgsql_2013, echo=FALSE, include=TRUE, eval=FALSE}
shp2pgsql -s 4258 -g geom -I ~/Data/NUTS/NUTS_2013_03M_SH/data/NUTS_RG_03M_2013 public.nuts_2013_poly | psql -h localhost -d nuts -U bdukai
```

Generate ID levels for NUTS 2013.

```{sql connection=db, include=TRUE}
CREATE
    OR REPLACE VIEW nuts_2013_levels AS WITH lvl0 AS(
        SELECT
            nuts_id id0
        FROM
            nuts_2013_poly
        WHERE
            stat_levl_ = 0
    ),
    lvl1 AS(
        SELECT
            a.*,
            b.nuts_id id1
        FROM
            lvl0 a
        JOIN nuts_2013_poly b ON
            a.id0 = SUBSTRING( b.nuts_id, 1, 2 )
        WHERE
            b.stat_levl_ = 1
    ),
    lvl2 AS(
        SELECT
            a.*,
            b.nuts_id id2
        FROM
            lvl1 a
        JOIN nuts_2013_poly b ON
            a.id1 = SUBSTRING( b.nuts_id, 1, 3 )
        WHERE
            b.stat_levl_ = 2
    ) SELECT
        a.*,
        b.nuts_id id3
    FROM
        lvl2 a
    JOIN nuts_2013_poly b ON
        a.id2 = SUBSTRING( b.nuts_id, 1, 4 )
    WHERE
        b.stat_levl_ = 3
    ORDER BY
        a.id0,
        a.id1,
        a.id2,
        b.nuts_id;
```

Generate point in the regions for version translation. 

```{sql connection=db, include=TRUE}
CREATE
    TABLE
        IF NOT EXISTS nuts_2013_pt AS SELECT
            gid,
            nuts_id,
            stat_levl_,
            st_pointonsurface(geom) geom
        FROM
            nuts_2013_poly;

ALTER TABLE
    nuts_2013_pt ADD PRIMARY KEY(gid);

CREATE
    INDEX nuts_2013_pt_geom_idx ON
    nuts_2013_pt
        USING gist(geom);
```

Get the view.

```{r nuts_2013, include=TRUE}
nuts_2013_levels <- dbReadTable(db, "nuts_2013_levels")
```


## Translate 2006 <-> 2010

NUTS3 regions are translated from version 2006 to 2010 by using a two-step spatial search. Firstly, the 2010 regions that were *merged* from 2006 to 2010 are spatially matched to 2006 regions, secondly the 2006 regions that were *split* from 2006 to 2010 are spatially matched to 2010 regions. Name changes and boundary shifts are also detected in the process. 

```{sql connection=db, include=TRUE}
CREATE
    OR replace VIEW nuts_translate_2006_2010 AS WITH nuts_match AS(
        -- case of merge in version 2006
        SELECT
            a.nuts_id nuts2006,
            b.nuts_id nuts2010
        FROM
            nuts_2006_pt a
        JOIN nuts_2010_poly b ON
            st_within(
                a.geom,
                b.geom
            )
        WHERE
            b.stat_levl_ = 3
            AND a.stat_levl_ = 3
    UNION
        -- case of split in version 2006
        SELECT
            b.nuts_id nuts2006,
            a.nuts_id nuts2010
        FROM
            nuts_2010_pt a
        JOIN nuts_2006_poly b ON
            st_within(
                a.geom,
                b.geom
            )
        WHERE
            b.stat_levl_ = 3
            AND a.stat_levl_ = 3
    ) SELECT
        *
    FROM
        nuts_match
    ORDER BY
        nuts2006;
```

```{r translation_schema, include=TRUE}
tbl_2010 <- dbReadTable(db, "nuts_translate_2006_2010")

tr_2006_2010 <- nuts_2010_levels %>%
    inner_join(tbl_2010, by = c("id3" = "nuts2010")) %>% 
    full_join(nuts_2006_levels, by = c("nuts2006" = "id3"),
              suffix = c(".2010", ".2006")) %>% 
    rename(id3.2010 = id3, id3.2006 = nuts2006)

rm(tbl_2010)
```

## Translate 2010 <-> 2013

```{sql connection=db, include=TRUE}
CREATE
    OR replace VIEW nuts_translate_2010_2013 AS WITH nuts_match AS(
        -- case of merge in version 2010
        SELECT
            a.nuts_id nuts2010,
            b.nuts_id nuts2013
        FROM
            nuts_2010_pt a
        JOIN nuts_2013_poly b ON
            st_within(
                a.geom,
                b.geom
            )
        WHERE
            b.stat_levl_ = 3
            AND a.stat_levl_ = 3
    UNION
        -- case of split in version 2010
        SELECT
            b.nuts_id nuts2010,
            a.nuts_id nuts2013
        FROM
            nuts_2013_pt a
        JOIN nuts_2010_poly b ON
            st_within(
                a.geom,
                b.geom
            )
        WHERE
            b.stat_levl_ = 3
            AND a.stat_levl_ = 3
    ) SELECT
        *
    FROM
        nuts_match
    ORDER BY
        nuts2010;
```

```{r translation_schema_2013, include=TRUE}
tbl_2013 <- dbReadTable(db, "nuts_translate_2010_2013")

tr_2010_2013 <- nuts_2013_levels %>%
    inner_join(tbl_2013, by = c("id3" = "nuts2013")) %>% 
    full_join(nuts_2010_levels, by = c("nuts2010" = "id3"),
              suffix = c(".2013", ".2010")) %>% 
    rename(id3.2013 = id3, id3.2010 = nuts2010)

rm(tbl_2013)
```

## EU member states

```{r eu_members}
eu_members <- data.frame(id0 = c("AT", "BE", "BG", "HR", "CY", "CZ", "DK", "EE",
                                 "FI", "FR", "DE", "EL", "HU", "IE", "IT", "LV",
                                 "LT", "LU", "MT", "NL", "PL", "PT", "RO", "SE",
                                 "SI", "SK", "ES", "UK"),
                         stringsAsFactors = FALSE)
```

## Population

Data source: Eurostats\
Nomenclature: NUTS2013 level 2 (only 2013 possible) [http://ec.europa.eu/eurostat/statistics-explained/index.php/Population_statistics_at_regional_level#NUTS](http://ec.europa.eu/eurostat/statistics-explained/index.php/Population_statistics_at_regional_level#NUTS)


```{r pop_in, include=TRUE}
# Read data
pop_2010 <- read.xlsx("~/Data/COHESIFY/Population/demo_r_d2jan.xls", sheetIndex = 1, colIndex = c(1,6), startRow = 11, endRow = 488, header = TRUE, stringsAsFactors = FALSE) %>% 
    rename(nuts)
```

# Territorial typology à border regions

*As described in Regional Focus No. 1/2011. The NUTS 3-based selection of border regions refers to the regions participating in the core areas of cross-border cooperation programmes in the programming period 2007-2013. Due to NUTS boundary changes, some current NUTS 3 regions are only partly eligible as programme areas. More information on how to apply the typology can be found in the guidance note.*

Value classification in the original data set:

+ 0 – No program area
+ 1 – Programme area
+ 9 – Programme area (partly)

This variable will become *regions that **participated** in the core areas of cross-border cooperation programmes in the programming period 2007-2013*. Because the values are from 2009, thus they use NUTS 2006 (not 2010), and they refer to the programming period 2007-2013.

```{r border_in, include=TRUE}
# Read data
typo_border_regions <- read.xlsx("~/Data/COHESIFY/Datasets for regression/Territorial typology/Typologies_metadata_data_final (2).xls", sheetName = "data regional typologies", colIndex = c(1,8), endRow = 1464, header = TRUE)
# remove rows with metadata
typo_border_regions <- filter(typo_border_regions, typ_border_A != 2009)
```

Join the NUTS3 2006 variable to the NUTS2-3 2010 regions using the 2006 <-> 2010 translation schema.

```{r join_2006_2010, include=TRUE}
# Join NUTS2-3 2010, NUTS3 2006, typ_border_A
typo_border_regions <- typo_border_regions %>% 
    full_join(tr_2006_2010, by = c("id" = "id3.2006")) %>% 
    inner_join(eu_members, by = c("id0.2010" = "id0")) %>% 
    rename(id2 = id2.2010, id3 = id3.2010) %>% 
    select(id2, id3, typ_border_A)
```

The aggregation of NUTS3 to NUTS2 is achieved by computing the precentage of *No programme / Programme / Programme (partly)* NUTS3 regions in the corresponding NUTS2 regions.

```{r border_aggregate, include=TRUE}
border_lvl2 <- typo_border_regions %>% 
    select(id2, typ_border_A) %>% 
    group_by(id2) %>%
    count(typ_border_A)
non_programme <- border_lvl2 %>% group_by(id2) %>% 
    mutate(nr_lvl3 = sum(n)) %>% 
    filter(typ_border_A == 0) %>% 
    mutate(non_programme = round(n/nr_lvl3, 2))
programme <- border_lvl2 %>% group_by(id2) %>% 
    mutate(nr_lvl3 = sum(n)) %>% 
    filter(typ_border_A == 1) %>% 
    mutate(programme = round(n/nr_lvl3, 2))
partially_programme <- border_lvl2 %>% group_by(id2) %>% 
    mutate(nr_lvl3 = sum(n)) %>% 
    filter(typ_border_A == 9) %>% 
    mutate(partially_programme = round(n/nr_lvl3, 2))
typ_border_lvl2_2006 <- nuts_2006_levels %>% select(id2) %>% 
    full_join(.,non_programme, by = "id2") %>% 
    full_join(., programme, by = "id2") %>%
    full_join(., partially_programme, by = "id2") %>% 
    select(id2, non_programme, programme, partially_programme) %>% 
    mutate(non_programme = case_when(is.na(.$non_programme) ~ 0.0,
                                     TRUE ~ .$non_programme)) %>% 
    mutate(programme = case_when(is.na(.$programme) ~ 0.0,
                                 TRUE ~ .$programme)) %>%
    mutate(partially_programme = case_when(is.na(.$partially_programme) ~ 0.0,
                                           TRUE ~ .$partially_programme))
rm(border_lvl2, programme, non_programme, partially_programme)
```

```{r border_clean, include=TRUE}
# Count records
x_total_cnt <- typ_border_lvl2_2006 %>% 
    count()
# Count valid records
x_2006_cnt <- typ_border_lvl2_2006 %>% 
    filter(non_programme == 0.0 &
               programme == 0.0 &
           partially_programme == 0.0)
# Remove the records that have 0 for each category, because they correspond to the NUTS2006 codes
typ_border_lvl2_clean <- typ_border_lvl2_2006 %>% 
    filter(!(non_programme == 0.0 &
               programme == 0.0 &
           partially_programme == 0.0))
```

```{r border_recode, include=TRUE}
typ_border_lvl2_encoded <- typ_border_lvl2_clean %>% 
    mutate(eligibility = case_when(.$non_programme == 1.0 ~ "not eligible",
                                  .$programme == 1.0 ~ "eligible",
                                  .$non_programme < 1.0 &
                                      .$programme < 1.0 ~ "partially"))
```



The results look like below:

```{r, results="asis", echo=FALSE}
knitr::kable(head(typ_border_lvl2_encoded), type = "html", title = "A sample of the translated \' Territorial boundaries á border regions \' variable")
```


```{r, include=TRUE}
write.csv(typ_border_lvl2_encoded, file = "./results/typ_border_lvl2_clean.csv",
          row.names = FALSE)
```

```{r clean_up}
rm(typ_border_lvl2_2006, typ_border_lvl2_clean, typo_border_regions, x_total_cnt, x_2006_cnt)
```

# Trust in national government

The question asked in the survey:

*I would like to ask you a question about how much trust you have in certain institutions. For each of the following institutions, please tell me if you tend to trust it or tend not to trust it.*

| The (NATIONALITY) Government | Tend to trust | Tend not to trust | DK |
|-----|------|------|----|
| – | 1 | 2 | 3 |

Data description says:\
*For all countries surveyed, a national weighting procedure, using marginal and intercellular weighting, was carried out based on this Universe description. In all countries, gender, age, region and size of locality were introduced in the iteration procedure. For international weighting (i.e. EU averages), TNS opinion & social applies the official population figures as provided by EUROSTAT or national statistic offices.*    

```{r read_trust, include=TRUE}
trust_raw <- read_sav("~/Data/COHESIFY/Datasets for regression/Trust in national government/ZA6694_v1-0-0 (1).sav")
```

From [European Values Study 2008](http://zacat.gesis.org/webview/index/en/ZACAT/ZACAT.c.ZACAT/European-Values-Study-EVS-.d.5/EVS-2008-4th-wave.d.1/EVS-2008-Integrated-Dataset.s.ZA4800/Archive-and-ID-Variables.h.175/country-abbreviation/fVariable/ZA4800_V11)

*AL Albania; AM Armenia; AT Austria; AZ Azerbaijan; BA Bosnia-Herzegovina; BE Belgium; BG Bulgaria; BY Belarus; CH Switzerland; CY Cyprus; CZ Czech Republic; DE Germany; DK Denmark; EE Estonia; ES Spain; FI Finland; FR France; GB-GBN Great Britain; GE Georgia; GR Greece; HR Croatia; HU Hungary; IE Ireland; IS Iceland; IT Italy; RS-KM Kosovo; LT Lithuania; LU Luxembourg; LV Latvia; MD Moldova; ME Montenegro; MK Macedonia; MT Malta; GB-NIR Northern Ireland; CY-TCC Northern Cyprus; NL Netherlands; NO Norway; PL Poland; PT Portugal; RO Romania; RS Serbia; RU Russia; SE Sweden; SI Slovenia; SK Slovakia; TK Turkey; UA Ukraine*

*All surveyed countries and regions, i.e. including separate samples for East-/West-Germany, Great Britain/Northern Ireland, Kosovo, and the Turkish Cypriot Community (TCC), are coded in accordance with the ISO 3166-1-alpha-2 country code, if available. ISO 3166-2 is applied for the United Kingdom subdivisions. ISO standard codes are not available for the “historical” East/West subdivision of Germany (DE-E/DE-W), Kosovo (RS-KM), and for the Turkish Cypriot Community in northern Cyprus (CY-TCC), the internationally not recognized “Turkish Republic of Northern Cyprus”.*

Countries in the study:

```{r}
table(trust_raw$isocntry)
```

Countries in the NUTS 2010 data:

```{r}
table(nuts_2010_levels$id0)
```

## Attribute translation

Dataset includes *AL* and *RS*, which are non-EU countries, thus the corresponding records are removed. Country codes that differ in the ISO standard and the NUTS declaration are translated using the schema below.


| ISO 3166-1-alpha-2; ISO 3166-2; historical | NUTS 0 | NUTS 1                                           |
|--------------------------------------------|--------|--------------------------------------------------|
| DE-E                                       | DE     | DEG, DED, DEE, DE3, DE4, DE8                     |
| DE-W                                       | DE     | DE1, DE2, DE5, DE6, DE7, DE9, DEA, DEB, DEC, DEF |
| GB-NIR                                     | UK     | UKN                                              |
| GB-GBN                                     | UK     | UK…                                              |
| CY-TCC                                     | CY     | CY0                                              |


```{r nuts_iso, include=TRUE}
# Translation schema for NUTS -> ISO3166/-2 & historical
nuts_2010_levels_iso <- nuts_2010_levels %>%
    mutate(iso = case_when(.$id1 == "UKN" ~ "GB-NIR",
                           .$id0 == "UK" & .$id1 != "UKN" ~ "GB-GBN",
                           .$id1 == "DE3" ~ "DE-E",
                           .$id1 == "DE4" ~ "DE-E",
                           .$id1 == "DE8" ~ "DE-E",
                           .$id1 == "DED" ~ "DE-E",
                           .$id1 == "DEE" ~ "DE-E",
                           .$id1 == "DEG" ~ "DE-E",
                           .$id1 == "DE1" ~ "DE-W",
                           .$id1 == "DE2" ~ "DE-W",
                           .$id1 == "DE5" ~ "DE-W",
                           .$id1 == "DE6" ~ "DE-W",
                           .$id1 == "DE7" ~ "DE-W",
                           .$id1 == "DE9" ~ "DE-W",
                           .$id1 == "DEA" ~ "DE-W",
                           .$id1 == "DEB" ~ "DE-W",
                           .$id1 == "DEC" ~ "DE-W",
                           .$id1 == "DEF" ~ "DE-W",
                           .$id0 == "EL" ~ "GR",
                           TRUE ~ .$id0
                           ))
# There is only a single NUTS region for Cyprus at all levels, but two
# values in the Trust data (CY, CY-TCC)
nuts_2010_levels_iso <- nuts_2010_levels_iso %>% 
    bind_rows(data.frame(id0 = "CY",
                         id1 = "CY0",
                         id2 = "CY00",
                         id3 = "CY000",
                         iso = "CY-TCC")) %>% 
    arrange(id0) %>% 
    select(-id3) %>% 
    distinct()
```


```{r trust_translate, include=TRUE}
trust_translate <- trust_raw %>% 
    select(isocntry, qa8a_7) %>% 
    inner_join(nuts_2010_levels_iso, by = c("isocntry" = "iso")) %>% 
    distinct() %>% 
    select(id2, qa8a_7) %>% 
    rename(trust_gov = qa8a_7) %>% 
    arrange(id2)
```

Get region codes

```{r}
# Test on Belgium
trust_be <- trust_raw %>% 
    filter(!is.na(p7be)) %>% 
    select(qa8a_7, qa8a_9, nuts, nutslvl, p7be, p7be_r)

# trust_raw$nuts correspond to the aproppriate NUTS regions and those that are encoded in trust_raw$p7*
```


```{r trust_regions, include=FALSE}
# NUTS regions that have values on a level
t_nuts2 <- trust_raw %>% 
    select(qa8a_7, qa8a_9, nuts, nutslvl) %>%
    filter(nutslvl == 2) %>%
    select(-nutslvl) %>% 
    filter(!all(is.na(qa8a_7), is.na(qa8a_9))) %>% 
    mutate(id0 = substr(nuts, 0, 2)) %>% 
    select(id0, nuts) %>% 
    distinct() %>% 
    arrange(id0) %>% 
    inner_join(eu_members, by = "id0")

t_nuts1 <- trust_raw %>% 
    select(qa8a_7, qa8a_9, nuts, nutslvl) %>%
    filter(nutslvl == 1) %>%
    select(-nutslvl) %>% 
    filter(!all(is.na(qa8a_7), is.na(qa8a_9))) %>% 
    mutate(id0 = substr(nuts, 0, 2)) %>% 
    select(id0, nuts) %>% 
    distinct() %>% 
    arrange(id0) %>% 
    inner_join(eu_members, by = "id0")

t_nuts0 <- trust_raw %>%
    select(qa8a_7, qa8a_9, nuts, nutslvl) %>%
    filter(nutslvl == 0) %>%
    select(-nutslvl) %>% 
    filter(!all(is.na(qa8a_7), is.na(qa8a_9))) %>% 
    select(nuts) %>% 
    distinct() %>% 
    arrange(nuts) %>% 
    inner_join(eu_members, by = c("nuts" = "id0")) %>% 
    mutate(x = 1)

### NUTS2
# nr. of nuts2 regions with missing values per country
no_id2 <- nuts_2010_levels %>% 
    inner_join(eu_members, by = "id0") %>% 
    select(-id3) %>% 
    full_join(t_nuts2, by = c("id2" = "nuts")) %>% 
    filter(is.na(id0.y)) %>% 
    distinct() %>% 
    group_by(id0.x) %>% 
    summarise(n_nuts2_missing = n()) %>% 
    rename(id0 = id0.x)

# nr. nuts2 regions with values per country
has_id2 <- nuts_2010_levels %>% 
    inner_join(eu_members, by = "id0") %>% 
    select(-id3) %>% 
    full_join(t_nuts2, by = c("id2" = "nuts")) %>% 
    filter(!is.na(id0.y)) %>%
    distinct() %>% 
    group_by(id0.x) %>% 
    summarise(n_nuts2 = n()) %>% 
    rename(id0 = id0.x)

# total nuts2 regions
total_id2 <- nuts_2010_levels %>% 
    select(id0, id2) %>% 
    distinct() %>% 
    group_by(id0) %>% 
    summarise(t_nuts2 = n())

### NUTS1
# nr. of nuts1 regions with missing values per country
no_id1 <- nuts_2010_levels %>% 
    inner_join(eu_members, by = "id0") %>% 
    select(-id3, -id2) %>% 
    full_join(t_nuts1, by = c("id1" = "nuts")) %>% 
    filter(is.na(id0.y)) %>% 
    distinct() %>% 
    group_by(id0.x) %>% 
    summarise(n_nuts1_missing = n()) %>% 
    rename(id0 = id0.x)

# nr. of nuts1 regions with values per country
has_id1 <- nuts_2010_levels %>% 
    inner_join(eu_members, by = "id0") %>% 
    select(-id3, -id2) %>% 
    full_join(t_nuts1, by = c("id1" = "nuts")) %>% 
    filter(!is.na(id0.y)) %>% 
    distinct() %>% 
    group_by(id0.x) %>% 
    summarise(n_nuts1 = n()) %>% 
    rename(id0 = id0.x)

# total nuts1 regions
total_id1 <- nuts_2010_levels %>% 
    select(id0, id1) %>% 
    distinct() %>% 
    group_by(id0) %>% 
    summarise(t_nuts1 = n())

### NUTS0
# nr. of nuts0 regions with missing values per country
has_id0 <- nuts_2010_levels %>% 
    inner_join(eu_members, by = "id0") %>% 
    select(-id3, -id2, -id1) %>% 
    full_join(t_nuts0, by = c("id0" = "nuts")) %>% 
    distinct()


# percent of regions with values per country
coverage_id <- total_id2 %>% 
    full_join(no_id2, by = "id0") %>% 
    full_join(has_id2, by = "id0") %>% 
    mutate(p_nuts2_coverage = case_when(is.na(.$n_nuts2_missing) ~ 100.0,
                                        is.na(.$n_nuts2) ~ 0.0,
                                        TRUE ~ round((.$n_nuts2 / 
                                                      .$t_nuts2)*100))) %>% 
    full_join(total_id1, by = "id0") %>% 
    full_join(has_id1, by = "id0") %>% 
    full_join(no_id1, by = "id0") %>% 
    mutate(p_nuts1_coverage = case_when(is.na(.$n_nuts1_missing) ~ 100.0,
                                        is.na(.$n_nuts1) ~ 0.0,
                                       TRUE ~ round((.$n_nuts1 /
                                                     .$t_nuts1)*100))) %>% 
    full_join(has_id0, by = "id0") %>% 
    mutate(p_nuts0_coverage = case_when(is.na(.$x) ~ 0.0,
                                        TRUE ~ 100.0)) %>% 
    inner_join(eu_members, by = "id0") %>% 
    rename(nr_n2_total = t_nuts2,
           nr_n2_miss = n_nuts2_missing,
           nr_n2_has = n_nuts2,
           p_n2_has = p_nuts2_coverage,
           nr_n1_total = t_nuts1,
           nr_n1_miss = n_nuts1_missing,
           nr_n1_has = n_nuts1,
           p_n1_has = p_nuts1_coverage,
           p_n0_has = p_nuts0_coverage) %>% 
    select(id0, nr_n2_total, nr_n2_miss, nr_n2_has, p_n2_has, nr_n1_total,
           nr_n1_miss, nr_n1_has, p_n1_has, p_n0_has)

# replace NA with 0 for easier interpretation
coverage_id[is.na(coverage_id)] <- 0

rm(has_id0, has_id1, has_id2, no_id1, no_id2, t_nuts0, t_nuts1, t_nuts2,
   total_id1, total_id2)
```

The coverage of the survey answers in the NUTS regions:

```{r, results='asis', echo=FALSE}
knitr::kable(coverage_id, caption = "The coverage of the answers pers NUTS regions for the questions \"Trust in national government and/or EU\"")
```

What could be problematic in this case is that three of the large countries with many NUTS2 regions, IT, DE, UK have only data on the NUTS1 level. Therefore the groups of the NUTS2 regions that take tha same value from the corresponding NUTS1 region could skew the regression outcome. Furthermore, some countries have no values at all. These countries are: **EE, HR, IE, LT, LV, SI**.

Notice that the countries that have records only on NUTS0 level, are composed of only one NUTS2 region. 

Nevertheless, lets prepare the output variables.

```{r trust_prep}
# Mapping NUTS0 -> NUTS2
val_lvl0 <- trust_raw %>%
    select(qa8a_7, qa8a_9, nuts, nutslvl) %>%
    filter(nutslvl == 0) %>%
    select(-nutslvl) %>% 
    inner_join(eu_members, by = c("nuts" = "id0")) %>% 
    inner_join(nuts_2010_levels, by = c("nuts" = "id0")) %>% 
    rename(trust_natgov = qa8a_7, trust_eu = qa8a_9) %>% 
    select(id2, trust_natgov, trust_eu)

# Mapping NUTS1 -> NUTS2
val_lvl1 <- trust_raw %>%
    select(qa8a_7, qa8a_9, nuts, nutslvl) %>%
    filter(nutslvl == 1) %>%
    select(-nutslvl) %>% 
    inner_join(nuts_2010_levels, by = c("nuts" = "id1")) %>% 
    inner_join(eu_members, by = "id0") %>%
    rename(trust_natgov = qa8a_7, trust_eu = qa8a_9) %>% 
    select(id2, trust_natgov, trust_eu)

# Put it together
trust_to_lvl2 <- trust_raw %>%
    select(qa8a_7, qa8a_9, nuts, nutslvl) %>%
    filter(nutslvl == 2) %>%
    inner_join(nuts_2010_levels, by = c("nuts" = "id2")) %>% 
    inner_join(eu_members, by = "id0") %>%
    rename(trust_natgov = qa8a_7, trust_eu = qa8a_9, id2 = nuts) %>% 
    select(id2, trust_natgov, trust_eu, -nutslvl) %>% 
    bind_rows(val_lvl0) %>% 
    bind_rows(val_lvl1)

nt <- trust_to_lvl2 %>% 
    group_by(id2) %>% 
    count(trust_natgov)

eu <- trust_to_lvl2 %>% 
    group_by(id2) %>% 
    count(trust_eu)

# compute how many of the respondents tend to trust the gov./eu in the 
# nuts regions
trust_level <- function(x, trust) {
    id2 <- unique(x$id2)
    for (ctry in id2) {
        tend_to_trust <- sum(x[x["id2"] == ctry & x[trust] == 1, "n"])
        total <- sum(x[x["id2"] == ctry, "n"])
        trust_value <- paste0(trust, "_value")
        x[x["id2"] == ctry, trust_value] <- (tend_to_trust / total)*100
    }
    return(x[c("id2", trust_value)])
}

# need to cast to data.frame to avoid funky errors
trust_pct <- trust_level(data.frame(nt), "trust_natgov") %>% 
    full_join(trust_level(data.frame(eu), "trust_eu"), by = "id2") %>% 
    distinct() %>% 
    arrange(id2) %>% 
    mutate(id0 = substr(id2, 0, 2), id1 = substr(id2, 0, 3))

# clean up
rm(nt, trust_be, trust_to_lvl2, trust_translate, val_lvl0, val_lvl1, eu, coverage_id, nuts_2010_levels_iso)
```

```{r trust_plot_de, echo=FALSE}
trust_pct %>% 
    filter(id0 == "DE") %>% 
    mutate(e_w = case_when(.$id1 == "DE3" ~ "DE-E",
                       .$id1 == "DE4" ~ "DE-E",
                       .$id1 == "DE8" ~ "DE-E",
                       .$id1 == "DED" ~ "DE-E",
                       .$id1 == "DEE" ~ "DE-E",
                       .$id1 == "DEG" ~ "DE-E",
                       .$id1 == "DE1" ~ "DE-W",
                       .$id1 == "DE2" ~ "DE-W",
                       .$id1 == "DE5" ~ "DE-W",
                       .$id1 == "DE6" ~ "DE-W",
                       .$id1 == "DE7" ~ "DE-W",
                       .$id1 == "DE9" ~ "DE-W",
                       .$id1 == "DEA" ~ "DE-W",
                       .$id1 == "DEB" ~ "DE-W",
                       .$id1 == "DEC" ~ "DE-W",
                       .$id1 == "DEF" ~ "DE-W"
                       )) %>% 
    distinct() %>% 
    ggplot(aes(trust_natgov_value, trust_eu_value, color = e_w)) +
        geom_point() +
        geom_text(aes(label = id1), hjust = 0, nudge_x = 0.05, size = 4) +
        labs(x = "Trust in national govt. (%) [NUTS2 regions]",
             y = "Trust in EU (%) [NUTS2 regions]",
             color = "Historical part:",
             title = "Level of trust in the national government and the EU",
             subtitle = "Germany per NUTS1 regions",
             caption = "Data: Eurobarometer 85.2; May 2016; ZA 6694 / ICPSR")
```

```{r trust_plot, echo=FALSE}
trust_pct %>% 
    ggplot(aes(trust_natgov_value, trust_eu_value, color = id0)) +
        geom_point() +
        geom_text(aes(label = id2), hjust = 0, nudge_x = 0.3, size = 3,
                  check_overlap = TRUE, color = "darkgrey", fontface = "bold") +
        labs(x = "Trust in national govt. (%) [NUTS2 regions]",
             y = "Trust in EU (%) [NUTS2 regions]",
             color = "Country",
             title = "Level of trust in the national government and the EU",
             subtitle = "EU members per NUTS2 regions",
             caption = "Data: Eurobarometer 85.2; May 2016; ZA 6694 / ICPSR")
```

Sample of the results:

```{r, results='asis', echo=FALSE}
knitr::kable(head(trust_translate), caption = "Trust in national government, NUTS 2010 level 2")
```

## Question

# Quality of Government

Source: THE QOG EU REGIONAL DATASET 2016

*Charron, Nicholas, Stefan Dahlberg, Sören Holmberg, Bo Rothstein, Anna Khomenko & Richard Svensson. 2016. The Quality of Government EU Regional Dataset, version Sep16. University of Gothenburg: The Quality of Government Institute, http://www.qog.pol.gu.se*

*Charron, Nicholas, Lewis Dijkstra and Victor Lapuente. 2015. Mapping the Regional Divide in Europe: A Measure for Assessing Quality of Government in 206 European Regions. Social Indicators Research. vol 122 (2): 315-346.*

*Charron, Nicholas, Lewis Dijkstra and Victor Lapuente. 2014. Regional Governance Matters: Quality of Government within European Union Member States. Regional Studies, 48(1): 68-90.*

*Charron, Nicholas, Victor Lapuente and Bo Rothstein. 2013. Quality of Government and Corruption from a European Perspective: A Comparative Study of Good Government in EU Regions. Edward Elgar Publishing.*

Date of access: 2016-04-25\
Nomenclature: NUTS 2006 level 2

Variable description (*eqi_eqi*):

*The European Quality of Government Index - the overall EQI regional estimates. The final regional index was the result of aggregating the scores for the three pillars for each region. **To calculate the final score for each country and region, the regional scores for each of the countries included in the 2013 survey were aggregated by regional population weights.** This national average of regional scores is used to elucidate the extent to which regionx in country conforms to the national QoG standard, which is done by subtracting the national average from each region's score. A positive score for a region implies that it is above the national mean; conversely, a negative score indicates that the regions QoG performance is below the national mean. In the final index, this regional score is added to the national WGI score, so that each region's score is adjusted; centered around the WGI. In combining the regional and WGI data, none of the regional variation within countries is lost.*


```{r read_qog, include=TRUE}
qog_raw <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/QoG/publishing-the-eqi-data2013.xlsx",
    sheetName = "EQI2013", colIndex = c(1,9), startRow = 4, endRow = 251, 
    header = TRUE, stringsAsFactors = FALSE) %>% 
    rename(nuts_2006 = NUTS, eqi_2013 = EQI.2013)
```

```{r qog_nuts2, include=TRUE}
# Get NUTS2 regions of input
qog_raw_nuts2 <- qog_raw %>% 
    select(nuts_2006) %>% 
    filter(nchar(nuts_2006) == 4)
```

Translate NUTS 2006 to 2010.

```{r qog_translate, include=TRUE}
qog_translate <- qog_raw %>% 
    filter(nchar(nuts_2006) >= 4) %>% 
    inner_join(tr_2006_2010, by = c("nuts_2006" = "id2.2006")) %>%
    rename(id2.2006 = nuts_2006) %>% 
    select(id2.2010, id2.2006, eqi_2013) %>% 
    distinct()
```

The comparison of the translated to the original reveals that the *EQI 2013* variables in fact use a mix of NTUS 2006/2010 regions, because *HR* is already mapped as NUTS 2010, while the rest of the countries as 2006.

```{r check_qog, include=TRUE}
no_match <- full_join(qog_translate, qog_raw_nuts2,
                      by = c("id2.2006" = "nuts_2006")) %>% 
    filter(is.na(eqi_2013)) %>% 
    arrange(id2.2006)
```

The error is corrected by manually assigning the value to *HR04*.

```{r correct_qog, include=TRUE}
qog_translate[qog_translate$id2.2010 == "HR04", "eqi_2013"] <- qog_raw[qog_raw$nuts_2006 == "HR04", "eqi_2013"]
```

```{r, results='asis', echo=FALSE}
knitr::kable(head(qog_translate), caption = "Sample of Quality of Government variable")
```


# Structural Funds eligibility 2007-2013, 2014-2020

Data: Structural Funds eligibility 2007-2013
Nomenclature: NUTS 2006, level 2

Data: Structural Funds eligibility 2014-2020
Nomenclature: NUTS 2013, level 2

```{r read_struct, include=TRUE}
struct_raw_2007 <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/SF eligibility/Database of the cumulative allocations to selected projects and expenditure at NUTS2 2007-2013.xlsx",
    sheetIndex = 1, colIndex = c(4,7), startRow = 1, endRow = 17208, 
    header = TRUE, stringsAsFactors = FALSE) %>% 
    rename(nuts_2006 = Location.Cd, class = Objective)
struct_raw_2014 <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/SF eligibility/Regional_policies_and_Europe_2020_RYB2016.xlsx",
    sheetIndex = 1, colIndex = c(1,4), startRow = 1, endRow = 287, 
    header = TRUE, stringsAsFactors = FALSE,
    colClasses = c("character", "numeric")) %>% 
    rename(nuts_2013 = NUTS, class = Class)
```

```{r struct_prep_2007, include=TRUE}
# Structural Funds Eligibility 2007-2013, Reshape into binary variables
struct_2007_prep <- struct_raw_2007 %>% 
    select(nuts_2006, class) %>% 
    distinct() %>% 
    arrange(nuts_2006) %>% 
    mutate(class = substr(class, 4, nchar(class))) %>% 
    spread(class, class)

names(struct_2007_prep) <- c("nuts_2006", "Competitiveness", "Convergence",
                             "Cooperation", "Multi.Objective")

struct_2007_prep[!is.na(struct_2007_prep$Competitiveness),
                 "Competitiveness"] <- 1
struct_2007_prep[!is.na(struct_2007_prep$Cooperation),
                 "Cooperation"] <- 1
struct_2007_prep[!is.na(struct_2007_prep$Convergence),
                 "Convergence"] <- 1
struct_2007_prep[!is.na(struct_2007_prep["Multi.Objective"]),
                 "Multi.Objective"] <- 1
struct_2007_prep[is.na(struct_2007_prep)] <- 0
```

```{r struct_2007_test}
# Testing: cooperation and multi-objective are not mutually exclusive, 
# convergence and competitiveness are mutually exclusive
struct_2007_prep %>% 
    filter(Convergence == 1 & Competitiveness == 1) %>% 
    arrange(nuts_2006)

# struct_raw_2007 %>% 
#     filter(nuts_2006 == "HU10" | nuts_2006 == "CZ01") %>% 
#     distinct() %>% 
#     arrange(nuts_2006)
```

```{r struct_prep_2014, include=TRUE}
# Structural Funds Eligibility 2014-2020, Reshape into binary variables
struct_2014_prep <- struct_raw_2014 %>% 
    select(nuts_2013, class) %>% 
    distinct() %>% 
    arrange(nuts_2013) %>% 
    mutate(class = case_when(.$class == 1 ~ "Less.Developed",
                             .$class == 2 ~ "Transition",
                             .$class == 3 ~ "More.Developed")) %>% 
    spread(class, class) %>% 
    select(nuts_2013, Less.Developed, Transition, More.Developed) %>% 
    inner_join(nuts_2013_levels, by = c("nuts_2013" = "id2")) %>% 
    select(-id0, -id1, -id3) %>% 
    distinct()

struct_2014_prep[!is.na(struct_2014_prep$Less.Developed),
                 "Less.Developed"] <- 1
struct_2014_prep[!is.na(struct_2014_prep$Transition),
                 "Transition"] <- 1
struct_2014_prep[!is.na(struct_2014_prep$More.Developed),
                 "More.Developed"] <- 1
struct_2014_prep[is.na(struct_2014_prep)] <- 0

# Testing: all 3 categories are mutually exclusive
struct_2014_prep %>% 
    filter(Less.Developed == 1 & Transition == 1)
struct_2014_prep %>% 
    filter(Less.Developed == 1 & More.Developed == 1)
struct_2014_prep %>% 
    filter(More.Developed == 1 & Transition == 1)
```

```{r, results='asis', echo=FALSE}
knitr::kable(head(struct_2007_prep), caption = "Structural Funds eligibility 2007-2013")
```


### Question


# Unemployment, population at risk of poverty

## Poverty rate(POV_RT)

People at risk of poverty or social exclusion, from *Europe 2020 Index based on the distances to 4 of the 8 Europe 2020 Strategy*.

Source: ESPON Database Portal\
Date of access: 2016-12-02 12:32:59\
Nomenclature: NUTS 2010 level 2

```{r pov_load, include=TRUE}
pov_raw <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/Employment and poverty/At-risk-of-poverty rate by NUTS 2 regions Eurostat_Table_tgs00103FlagDesc_58269b17-0d0c-47bb-af35-714d1b24e497.xls",
    sheetIndex = 1, colIndex = c(1,14), startRow = 3, endRow = 184, 
    header = TRUE, stringsAsFactors = FALSE, colClasses = c("character", "numeric"))
names(pov_raw) <- c("nuts_2010", "poverty_2013")
```

The coverage is heterogenous, some countries have NUTS2 level poverty values, while others are aggregae to NUTS0 level. The poverty values on NUTS0 level are the weighted average of the poverty values of the lower level NUTS regions, if these values exists.

```{r pov_prep, include=TRUE}
pov_lvl0 <- pov_raw %>% filter(nchar(nuts_2010) == 2) %>% 
    rename(id0 = nuts_2010)
pov_lvl1 <- pov_raw %>% filter(nchar(nuts_2010) == 3) %>% 
    mutate(id0 = substr(nuts_2010, 0, 2)) %>% 
    rename(id1 = nuts_2010)
pov_lvl2 <- pov_raw %>% filter(nchar(nuts_2010) == 4) %>% 
    mutate(id0 = substr(nuts_2010, 0, 2)) %>% 
    rename(id2 = nuts_2010) %>% 
    inner_join(eu_members, by = "id0")

pov_all <- pov_lvl0 %>% 
    full_join(pov_lvl1, by = "id0", suffix = c(".id0", ".id1")) %>% 
    full_join(pov_lvl2, by = "id0") %>% 
    rename(poverty_2013.id2 = poverty_2013) %>% 
    inner_join(eu_members, by = "id0") %>%
    arrange(id0)

# The list of countries that have only NUTS0 level poverty values
pov_cntry <- pov_all %>% 
    filter(is.na(poverty_2013.id2) & is.na(poverty_2013.id1)) %>%
    select(id0, poverty_2013.id0) %>% 
    distinct()
```

In case of the countries that have only NUTS0 level poverty values, the country value is inputed for all NUTS2 regions.

```{r,echo=FALSE}
pov_cntry$id0
```

Combine everything and input country average for the missing values in Finland.

```{r pov_combine, include=TRUE}
pov_nuts2 <- pov_cntry %>% 
    inner_join(nuts_2010_levels, by = "id0") %>% 
    select(id2, poverty_2013.id0) %>% 
    rename(poverty_2013 = poverty_2013.id0) %>% 
    distinct() %>% 
    bind_rows(select(pov_lvl2, id2, poverty_2013)) %>% 
    arrange(id2)

# input country average for the missing values in Finland
pov_nuts2[substr(pov_nuts2$id2, 0, 2) == "FI" & is.na(pov_nuts2$poverty_2013),
          "poverty_2013"] <- pov_lvl0[pov_lvl0$id0 == "FI", "poverty_2013"]
```

```{r, results='asis', echo=FALSE}
knitr::kable(head(pov_nuts2), caption = "People at risk of poverty or social exclusion, NUTS 2010 level 2")
```


### Question

1. The values are not weighted "back" from NUTS0 –> NUTS2, because we don't know the contribution of each NUTS2 region. However, the NUTS0 aggregates are seemingly the weighted averages of the lower level values.

2. But didn't find description on the weighting of the values.

## Unemployment

Unemployment rate of persons aged 15-74.

```{r unemp_load, include=TRUE}
unemp_raw <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/Employment and poverty/Unemployment rates by sex, age and NUTS 2 regions (_) lfst_r_lfu3rt.xls",
    sheetIndex = 1, colIndex = c(1,4), startRow = 11, endRow = 502, 
    header = TRUE, stringsAsFactors = FALSE, colClasses = c("character", "numeric"))
names(unemp_raw) <- c("nuts_2013", "unemployment_2013")
```

Translate NUTS 2013 to 2010.

```{r unemp_translate, include=TRUE}
unemp_translate <- unemp_raw %>%
    filter(nchar(nuts_2013) >= 4) %>% 
    inner_join(tr_2010_2013, by = c("nuts_2013" = "id2.2013")) %>% 
    select(id2.2010, unemployment_2013) %>% 
    distinct()
```

```{r, results='asis', echo=FALSE}
knitr::kable(head(unemp_translate), caption = "Unemployment rate of persons aged 15-74, NUTS 2010 level 2")
```

### Question

1. Same weighting question as above.

# Educational attainment (tertiary)

Population aged 25-64 with tertiary education, NUTS 2 regions (%) [edat_lfse_04].

Source: Eurostat\
Last update: 2016-10-13\
Date of access: 2016-12-04\
Nomenclature: NUTS 2013 level 2

Description: [http://ec.europa.eu/eurostat/cache/metadata/en/edat1_esms.htm](http://ec.europa.eu/eurostat/cache/metadata/en/edat1_esms.htm)

The data are calculated as annual averages of quarterly EU Labour Force Survey data (EU-LFS).

Up to the reference year 2008, the data source (EU-LFS) is, where necessary, adjusted and enriched in various ways, in accordance with the specificities of an indicator, including the following:

+ correction of the main breaks in the LFS series,
+ estimation of the missing values, i.e. in case of missing quarters, annual results and EU aggregates are estimated using adjusted quarterly national labour force survey data or interpolations of the EU-LFS data with reference to the available quarter(s).

Details on the adjustments are available in [CIRCABC](https://circabc.europa.eu/faces/jsp/extension/wai/navigation/container.jsp).

```{r edu_load, include=TRUE}
edu_raw <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/Education/Population aged 25-64 with tertiary education (EUROSTAT) edat_lfse_04.xls",
    sheetIndex = 1, colIndex = c(1,4), startRow = 12, endRow = 497, 
    header = TRUE, stringsAsFactors = FALSE, colClasses = c("character", "numeric"))
names(edu_raw) <- c("nuts_2013", "education_2013")
```

Translate NUTS 2013 to 2010.

```{r edu_translate, include=TRUE}
edu_translate <- edu_raw %>%
    filter(nchar(nuts_2013) >= 4) %>% 
    inner_join(tr_2010_2013, by = c("nuts_2013" = "id2.2013")) %>% 
    select(id2.2010, education_2013) %>% 
    distinct()
```

```{r, results='asis', echo=FALSE}
knitr::kable(head(edu_translate), caption = "Population aged 25-64 with tertiary education, NUTS 2010 level 2 regions (%) [edat_lfse_04]")
```


# Social progress (Basic Human Needs, Wellbeing, Opportunity)

```{r soc_load, include=TRUE}
soc_raw <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/Social Progress Index/2016_eu_spi.xlsx",
    sheetIndex = 1, colIndex = c(1,4), startRow = 1, endRow = 273, 
    header = TRUE, stringsAsFactors = FALSE,
    colClasses = c("character", "numeric")) %>% 
    rename(nuts_2010 = NUTS.Code.2010,
           soc_idx = European.Union.Regional.Social.Progress.Index)
```

```{r, results='asis', echo=FALSE}
knitr::kable(head(soc_raw), caption = "Social progress, NUTS 2010 level 2")
```

# Population change, net migration

Population change - Demographic balance and crude rates at regional level (NUTS 3) [demo_r_gind3]

Source: Eurostat\
Last update: 2016-10-28\
Date of access: 2016-12-04\
Nomenclature: NUTS 2010/2013 level 3

There are values for all NUTS levels, thus there is no need to aggregate NUTS3, just select NUTS2.

```{r migr_load, include=TRUE}
migr_raw <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/Migration/Crude rate of net migration plus statistical adjustment demo_r_gind3.xls",
    sheetIndex = 1, colIndex = c(1,4), startRow = 9, endRow = 2119, 
    header = TRUE, stringsAsFactors = FALSE, colClasses = c("character", "numeric"))
names(migr_raw) <- c("nuts_2010", "migration_2013")
```

```{r migr_prep, include=TRUE}
migr_prep <- migr_raw %>% 
    filter(nchar(nuts_2010) == 4) %>% 
    mutate(id0 = substr(nuts_2010, 0, 2)) %>% 
    inner_join(eu_members, by = "id0") %>% 
    select(-id0)

# The 2013 regions that in the data but are not NUTS 2010 regions
n2013 <- migr_prep %>% 
    full_join(nuts_2010_levels, by = c("nuts_2010" = "id2")) %>% 
    select(-id3) %>% 
    distinct() %>% 
    filter(is.na(id0))

# The 2010 regions that are in the data but are not NUTS 2013 regions
n2010 <- migr_prep %>% 
    full_join(nuts_2013_levels, by = c("nuts_2010" = "id2")) %>% 
    select(-id3) %>% 
    distinct() %>% 
    filter(is.na(id0))

# Put it together and filter out 2013 regions
migr_clean <- migr_prep %>%
    filter(!(nuts_2010 %in% n2013$nuts_2010)) %>% 
    arrange(nuts_2010) %>% 
    rename(id2 = nuts_2010)
```

```{r migr_check, include=TRUE}
# Check if all EU members are present, should give 28
migr_clean %>%
    mutate(x = substr(id2, 0, 2)) %>% 
    select(x) %>% 
    n_distinct()
```


The data set uses a NUTS 2010 nomenclature but still the NUTS1 regions *EL5* and *EL6* are present, duplicating the values of their corresponding NUTS 2010 regions (*EL1* and *EL2*). Therefore *EL5* and *EL6* are removed.

Similarly in case of France, the NUTS 2010 regions *FR91, FR92, FR93, FR94* are present, and also their corresponding NUTS 2013 versions *FRA2, FRA3, FRA4*, while *FRA1, FRA5* is missing value. The NUTS 2013 regions present novel data compared to their 2010 version. Because the majority of the data correspond to NUTS 2010 regions, the NUTS 2013 regions of France are removed.

```{r, results='asis', echo=FALSE}
knitr::kable(head(migr_clean), caption = "Population change, NUTS 2010 level 2")
```

# Access to social services

The record for *Saarland* was missing its NUTS code thus it was manually added.

```{r acc2soc_load, include=TRUE}
acc2soc_raw <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/Access to services/SGI typology.xlsx",
    sheetIndex = 1, colIndex = c(1,7), startRow = 1, endRow = 287, 
    header = TRUE, stringsAsFactors = FALSE) %>% 
    rename(nuts_2006 = NUTS2, sgi_aggregated = SGI.aggreg.)
```

Translate NUTS 2006 to 2010.

```{r acc2soc_tranlate, include=TRUE}
acc2soc_translate <- acc2soc_raw %>% 
    inner_join(tr_2006_2010, by = c("nuts_2006" = "id2.2006")) %>% 
    rename(id2.2006 = nuts_2006) %>% 
    select(id2.2010, sgi_aggregated) %>% 
    distinct() %>% 
    mutate(x = substr(id2.2010, 0, 2)) %>% 
    inner_join(eu_members, by = c("x" = "id0"))
```

Compare the translated and the original to check if everything is correct. Croatia (*HR*) is not present in the data.

```{r check_acc2soc, include=TRUE}
# Check if all EU members are present, should give 28
acc2soc_translate %>%
    mutate(x = substr(id2.2010, 0, 2)) %>% 
    select(x) %>% 
    distinct()
```

```{r, results='asis', echo=FALSE}
knitr::kable(head(acc2soc_translate), caption = "Access to social services, NUTS 2010 level 2")
```

# Share of population employed in agriculture

Agriculture, forestry and fishing; mining and quarrying\
Percentage of total employment


```{r agr_load, include=TRUE}
agr_raw <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/Agriculture/htec_emp_reg2.xls",
    sheetIndex = 1, colIndex = c(1,7), startRow = 1442, endRow = 1910, 
    header = TRUE, stringsAsFactors = FALSE,
    colClasses = c("character", "numeric")) %>% 
    rename(x = GEO.TIME,
           agr_share = X2013)
```

```{r agr_prep, include=TRUE}
agr_clean <- agr_raw
agr_clean$nuts_2010 <- unlist(lapply(strsplit(agr_raw$x, " "), function(x) x[1]))
agr_clean <- agr_clean %>% select(-x)

agr_lvl0 <- agr_clean %>% filter(nchar(nuts_2010) == 2) %>% 
    rename(id0 = nuts_2010)
agr_lvl1 <- agr_clean %>% filter(nchar(nuts_2010) == 3) %>% 
    mutate(id0 = substr(nuts_2010, 0, 2)) %>% 
    rename(id1 = nuts_2010)
agr_lvl2 <- agr_clean %>% filter(nchar(nuts_2010) == 4) %>% 
    mutate(id0 = substr(nuts_2010, 0, 2)) %>% 
    mutate(id1 = substr(nuts_2010, 0, 3)) %>% 
    rename(id2 = nuts_2010)

agr_all <- agr_lvl0 %>% 
    full_join(agr_lvl1, by = "id0", suffix = c(".id0", ".id1")) %>% 
    full_join(agr_lvl2, by = "id1") %>% 
    rename(agr_share.id2 = agr_share, id0 = id0.x) %>% 
    select(-id0.y) %>%
    inner_join(eu_members, by = "id0") %>% 
    arrange(id0)

# Input country average to missing NUTS2 values
missing <- agr_all %>% filter(is.na(agr_share.id2))

for (r in missing$id2) {
    # if NUTS1 value missing
    if (is.na(agr_all[agr_all$id2 == r, "agr_share.id1"])) {
        agr_all[agr_all$id2 == r,
                "agr_share.id2"] <- agr_all[agr_all$id2 == r, "agr_share.id0"]
    } else {
    # NUTS1 value present
        agr_all[agr_all$id2 == r,
                "agr_share.id2"] <- agr_all[agr_all$id2 == r, "agr_share.id1"]
    }
}

agr_clean <- agr_all %>%
    select(id2, agr_share.id2) %>% 
    rename(agr_share = agr_share.id2)
```

The NUTS2 regions below are missing values. For these regions the corresponding NUTS1 value is inputed if available, otherwise the corresponding NUTS0 value.

```{r agr_missing_table, results='asis', echo=FALSE}
knitr::kable(missing, caption = "NUTS2 regions with missing agriculture index values")
```

```{r, results='asis', echo=FALSE}
knitr::kable(head(agr_clean), caption = "Share of population employed in agriculture, NUTS 2010 level 2")
```

### Question

# EU Identification

```{r eu_id_load, include=TRUE}
eu_id <- read.xlsx(
    "~/Data/COHESIFY/Datasets for regression/EU Identification/EU Identification typology (COHESIFY Output 2.4a).xlsx",
    sheetIndex = 1, colIndex = c(1,3,4), startRow = 1, endRow = 273, 
    header = TRUE, stringsAsFactors = FALSE,
    colClasses = c("character", "numeric", "character"))
```